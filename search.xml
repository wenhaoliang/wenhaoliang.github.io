<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Redis学习笔记-04】三种特殊数据类型</title>
      <link href="/2020/06/05/redis-xue-xi-bi-ji-04-san-chong-te-shu-shu-ju-lei-xing/"/>
      <url>/2020/06/05/redis-xue-xi-bi-ji-04-san-chong-te-shu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h1><p>朋友的定位，附近的人，打车距离计算？</p><p>Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆<br>几里的人！</p><p>可以查询一些测试数据：<a href="http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/" target="_blank" rel="noopener">http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/</a></p><p>只有 六个命令：  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04%E3%80%91%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200609113454185.png" alt="Geospatial 地理位置  六个命令"></p><p>官方文档：<a href="https://www.redis.net.cn/order/3685.html" target="_blank" rel="noopener">https://www.redis.net.cn/order/3685.html</a>  </p><blockquote><p>getadd</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># getadd 添加地理位置</span><span class="token comment" spellcheck="true"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</span><span class="token comment" spellcheck="true"># 有效的经度从-180度到180度。</span><span class="token comment" spellcheck="true"># 有效的纬度从-85.05112878度到85.05112878度。</span><span class="token comment" spellcheck="true"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span><span class="token comment" spellcheck="true"># 127.0.0.1:6379> geoadd china:city 39.90 116.40 beijin</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR invalid longitude,latitude pair 39.900000,116.400000<span class="token comment" spellcheck="true"># 参数 key 值（）</span>127.0.0.1:6379<span class="token operator">></span> geoadd china:city 116.40 39.90 beijing<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> geoadd china:city 121.47 31.23 shanghai<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2127.0.0.1:6379<span class="token operator">></span> geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre><blockquote><p>getpods</p></blockquote><pre class=" language-bas"><code class="language-bas">#获得当前定位：一定是一个坐标值！127.0.0.1:6379> GEOPOS china:city beijing # 获取指定的城市的经度和纬度！1) 1) "116.39999896287918091"2) "39.90000009167092543"127.0.0.1:6379> GEOPOS china:city beijing chongqi1) 1) "116.39999896287918091"2) "39.90000009167092543"2) 1) "106.49999767541885376"2) "29.52999957900659211"</code></pre><blockquote><p>GEODIST</p></blockquote><p>两人之间的距离！</p><p>单位：</p><p>m 表示单位为米。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> GEODIST china:city beijing shanghai km # 查看上海到北京的直线距离"1067.3788"127.0.0.1:6379> GEODIST china:city beijing chongqi km # 查看重庆到北京的直线距离"1464.0708"</code></pre><blockquote><p>georadius 以给定的经纬度为中心， 找出某一半径内的元素  </p></blockquote><p>我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！</p><p>获得指定数量的人，200</p><p>所有数据应该都录入：china:city ，才会让结果更加请求！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> GEORADIUS china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻找方圆1000km内的城市1) "chongqi"2) "xian"3) "shengzhen"4) "hangzhou"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km1) "chongqi"2) "xian"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist # 显示到中间距离的位置1) 1) "chongqi"2) "341.9374"2) 1) "xian"2) "483.8340"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息1) 1) "chongqi"2) 1) "106.49999767541885376"2) "29.52999957900659211"2) 1) "xian"2) 1) "108.96000176668167114"2) "34.25999964418929977"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist withcoord count 1 #筛选出指定的结果！1) 1) "chongqi"2) "341.9374"3) 1) "106.49999767541885376"2) "29.52999957900659211"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist withcoord count 21) 1) "chongqi"2) "341.9374"3) 1) "106.49999767541885376"2) "29.52999957900659211"2) 1) "xian"2) "483.8340"3) 1) "108.96000176668167114"2) "34.25999964418929977"</code></pre><blockquote><p>GEORADIUSBYMEMBER  </p></blockquote><pre class=" language-ba"><code class="language-ba"># 找出位于指定元素周围的其他元素！127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing 1000 km1) "beijing"2) "xian"127.0.0.1:6379> GEORADIUSBYMEMBER china:city shanghai 400 km1) "hangzhou"2) "shanghai"</code></pre><blockquote><p>GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示  </p></blockquote><p>该命令将返回11个字符的Geohash字符串!  </p><pre class=" language-bas"><code class="language-bas"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！127.0.0.1:6379> geohash china:city beijing chongqi1) "wx4fbxxfke0"2) "wm5xzrybty0"</code></pre><blockquote><p>GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！  </p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> ZRANGE china:city 0 -1 # 查看地图中全部的元素1) "chongqi"2) "xian"3) "shengzhen"4) "hangzhou"5) "shanghai"6) "beijing"127.0.0.1:6379> zrem china:city beijing # 移除指定元素！(integer) 1127.0.0.1:6379> ZRANGE china:city 0 -11) "chongqi"2) "xian"3) "shengzhen"4) "hangzhou"5) "shanghai"</code></pre><h1 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h1><blockquote><p>什么是基数？</p></blockquote><p>A {1,3,5,7,8,7}</p><p>B{1,3,5,7,8}</p><p>基数（不重复的元素） = 5，可以接受误差！</p><blockquote><p>简介</p></blockquote><p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p><p>Redis Hyperloglog 基数统计的算法！  </p><p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的<br>话 Hyperloglog 首选！</p><p><strong>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</strong></p><p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !</p><p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p><p>0.81% 错误率！ 统计UV任务，可以忽略不计的  </p><blockquote><p>测试使用</p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey(integer) 1127.0.0.1:6379> PFCOUNT mykey # 统计 mykey 元素的基数数量(integer) 10127.0.0.1:6379> PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2(integer) 1127.0.0.1:6379> PFCOUNT mykey2(integer) 9127.0.0.1:6379> PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 => mykey3 并集OK127.0.0.1:6379> PFCOUNT mykey3 # 看并集的数量！(integer) 15</code></pre><p>如果允许容错，那么一定可以使用 Hyperloglog ！</p><p>如果不允许容错，就使用 set 或者自己的数据类型即可！  </p><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><blockquote><p>位存储</p></blockquote><p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用<br>Bitmaps！</p><p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！</p><p>365 天 = 365 bit 1字节 = 8bit 46 个字节左右！  </p><blockquote><p>测试</p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04%E3%80%91%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200609114206489.png" alt="Bitmap "></p><p>使用bitmap 来记录 周一到周日的打卡！</p><p>周一：1 周二：0 周三：0 周四：1 ……  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04%E3%80%91%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200609114250548.png" alt="周一到周日的打卡"></p><p>查看某一天是否有打卡！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> getbit sign 3(integer) 1127.0.0.1:6379> getbit sign 6(integer) 0</code></pre><p>统计操作，统计 打卡的天数！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！(integer) 3</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-05】事务</title>
      <link href="/2020/06/05/redis-xue-xi-bi-ji-05-shi-wu/"/>
      <url>/2020/06/05/redis-xue-xi-bi-ji-05-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按<br>照顺序执行！</p><p>一次性、顺序性、排他性！执行一些列的命令！  </p><pre class=" language-bas"><code class="language-bas">------ 队列 set set set 执行------</code></pre><p><strong>Redis事务没有没有隔离级别的概念！</strong></p><p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec</p><p><strong>Redis单条命令式保存原子性的，但是事务不保证原子性！</strong></p><p>redis的事务：</p><ul><li>开启事务（multi）</li><li>命令入队（……）</li><li>执行事务（exec）</li></ul><blockquote><p>正常执行事务！</p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> multi # 开启事务OK# 命令入队127.0.0.1:6379> set k1 v1QUEUED127.0.0.1:6379> set k2 v2QUEUED127.0.0.1:6379> get k2QUEUED127.0.0.1:6379> set k3 v3QUEUED127.0.0.1:6379> exec # 执行事务1) OK2) OK3) "v2"4) OK</code></pre><blockquote><p>放弃事务！  </p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> multi # 开启事务OK127.0.0.1:6379> set k1 v1QUEUED127.0.0.1:6379> set k2 v2QUEUED127.0.0.1:6379> set k4 v4QUEUED127.0.0.1:6379> DISCARD # 取消事务OK127.0.0.1:6379> get k4 # 事务队列中命令都不会被执行！(nil)</code></pre><blockquote><p> 编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！</p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> multiOK127.0.0.1:6379> set k1 v1QUEUED127.0.0.1:6379> set k2 v2QUEUED127.0.0.1:6379> set k3 v3QUEUED127.0.0.1:6379> getset k3 # 错误的命令(error) ERR wrong number of arguments for 'getset' command127.0.0.1:6379> set k4 v4QUEUED127.0.0.1:6379> set k5 v5QUEUED127.0.0.1:6379> exec # 执行事务报错！(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379> get k5 # 所有的命令都不会被执行！(nil)</code></pre><blockquote><p> 运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！  </p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> set k1 "v1"OK127.0.0.1:6379> multiOK127.0.0.1:6379> incr k1 # 会执行的时候失败！QUEUED127.0.0.1:6379> set k2 v2QUEUED127.0.0.1:6379> set k3 v3QUEUED127.0.0.1:6379> get k3QUEUED127.0.0.1:6379> exec1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！2) OK3) OK4) "v3"127.0.0.1:6379> get k2"v2"127.0.0.1:6379> get k3"v3"</code></pre><blockquote><p>*<em>监控！ Watch （面试常问！）  *</em></p></blockquote><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否<br>有人修改过这个数据，</li><li>获取version</li><li>更新的时候比较 version  </li></ul><blockquote><p>Redis测监视测试  </p></blockquote><p>  正常执行成功！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> set money 100OK127.0.0.1:6379> set out 0OK127.0.0.1:6379> watch money # 监视 money 对象OK127.0.0.1:6379> multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！OK127.0.0.1:6379> DECRBY money 20QUEUED127.0.0.1:6379> INCRBY out 20QUEUED127.0.0.1:6379> exec1) (integer) 802) (integer) 20</code></pre><p>测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> watch money # 监视 moneyOK127.0.0.1:6379> multiOK127.0.0.1:6379> DECRBY money 10QUEUED127.0.0.1:6379> INCRBY out 10QUEUED127.0.0.1:6379> exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！(nil)</code></pre><p>如果修改失败，获取最新的值就好  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> UNWATCH #如果发现事务执行失败，就先解锁OK127.0.0.1:6379> watch money #获取最新的值，再次监视，select versionOK127.0.0.1:6379> multiQUEUED127.0.0.1:6379> DECRBY money 1QUEUED127.0.0.1:6379> INCRBY money 1QUEUED127.0.0.1:6379> exec #对比监视的值师傅发生了变化，如果没有变化，就可以执行成功，如果发生了变化就执行失败1)(integer) 9991)(integer) 1000</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-03】五大数据类型</title>
      <link href="/2020/06/03/redis-xue-xi-bi-ji-03-wu-da-shu-ju-lei-xing/"/>
      <url>/2020/06/03/redis-xue-xi-bi-ji-03-wu-da-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> keys * # 查看所有的key(empty list or set)127.0.0.1:6379> set name lazyworm # set keyOK127.0.0.1:6379> keys *1) "name"127.0.0.1:6379> set age 1OK127.0.0.1:6379> keys *1) "age"2) "name"127.0.0.1:6379> EXISTS name # 判断当前的key是否存在(integer) 1127.0.0.1:6379> EXISTS name1(integer) 0127.0.0.1:6379> move name 1 # 移除当前的key(integer) 1127.0.0.1:6379> keys *1) "age"127.0.0.1:6379> set name lazywormOK127.0.0.1:6379> keys *1) "age"2) "name"127.0.0.1:6379> clear127.0.0.1:6379> keys *1) "age"2) "name"127.0.0.1:6379> get name"lazyworm"127.0.0.1:6379> EXPIRE name 10 # 设置key的过期时间，单位是秒(integer) 1127.0.0.1:6379> ttl name # 查看当前key的剩余时间(integer) 4127.0.0.1:6379> ttl name(integer) 3127.0.0.1:6379> ttl name(integer) 2127.0.0.1:6379> ttl name(integer) 1127.0.0.1:6379> ttl name(integer) -2127.0.0.1:6379> get name(nil)127.0.0.1:6379> type name # 查看当前key的一个类型！string127.0.0.1:6379> type agestring</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre class=" language-ba"><code class="language-ba">##########################################################################127.0.0.1:6379> set key1 v1 # 设置值OK127.0.0.1:6379> get key1 # 获得值"v1"127.0.0.1:6379> keys * # 获得所有的key1) "key1"127.0.0.1:6379> EXISTS key1 # 判断某一个key是否存在(integer) 1127.0.0.1:6379> APPEND key1 "hello" # 追加字符串，如果当前key不存在，就相当于setkey(integer) 7127.0.0.1:6379> get key1"v1hello"127.0.0.1:6379> STRLEN key1 # 获取字符串的长度！(integer) 7127.0.0.1:6379> APPEND key1 ",lazyworm"(integer) 17127.0.0.1:6379> STRLEN key1(integer) 17127.0.0.1:6379> get key1"v1hello,lazyworm"########################################################################### i++# 步长 i+=127.0.0.1:6379> set views 0 # 初始浏览量为0OK127.0.0.1:6379> get views"0"127.0.0.1:6379> incr views # 自增1 浏览量变为1(integer) 1127.0.0.1:6379> incr views(integer) 2127.0.0.1:6379> get views"2"127.0.0.1:6379> decr views # 自减1 浏览量-1(integer) 1127.0.0.1:6379> decr views(integer) 0127.0.0.1:6379> decr views(integer) -1127.0.0.1:6379> get views"-1"127.0.0.1:6379> INCRBY views 10 # 可以设置步长，指定增量！(integer) 9127.0.0.1:6379> INCRBY views 10(integer) 19127.0.0.1:6379> DECRBY views 5(integer) 14########################################################################### 字符串范围 range127.0.0.1:6379> set key1 "hello,lazyworm" # 设置 key1 的值OK127.0.0.1:6379> get key1"hello,lazyworm"127.0.0.1:6379> GETRANGE key1 0 3 # 截取字符串 [0,3]"hell"127.0.0.1:6379> GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的"hello,lazyworm"# 替换！127.0.0.1:6379> set key2 abcdefgOK127.0.0.1:6379> get key2"abcdefg"127.0.0.1:6379> SETRANGE key2 1 xx # 替换指定位置开始的字符串！(integer) 7127.0.0.1:6379> get key2"axxdefg"########################################################################### setex (set with expire) # 设置过期时间# setnx (set if not exist) # 不存在在设置 （在分布式锁中会常常使用！）127.0.0.1:6379> setex key3 30 "hello" # 设置key3 的值为 hello,30秒后过期OK127.0.0.1:6379> ttl key3(integer) 26127.0.0.1:6379> get key3"hello"127.0.0.1:6379> setnx mykey "redis" # 如果mykey 不存在，创建mykey(integer) 1127.0.0.1:6379> keys *1) "key2"2) "mykey"3) "key1"127.0.0.1:6379> ttl key3(integer) -2127.0.0.1:6379> setnx mykey "MongoDB" # 如果mykey存在，创建失败！(integer) 0127.0.0.1:6379> get mykey"redis"##########################################################################msetmget127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3 # 同时设置多个值OK127.0.0.1:6379> keys *1) "k1"2) "k2"3) "k3"127.0.0.1:6379> mget k1 k2 k3 # 同时获取多个值1) "v1"2) "v2"3) "v3"127.0.0.1:6379> msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起失败！(integer) 0127.0.0.1:6379> get k4(nil)# 对象set user:1 {name:zhangsan,age:3} # 设置一个user:1 对象 值为 json字符来保存一个对象！# 这里的key是一个巧妙的设计： user:{id}:{filed} , 如此设计在Redis中是完全OK了！127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379> mget user:1:name user:1:age1) "zhangsan"2) "2"##########################################################################getset # 先get然后在set127.0.0.1:6379> getset db redis # 如果不存在值，则返回 nil(nil)127.0.0.1:6379> get db"redis127.0.0.1:6379> getset db mongodb # 如果存在值，获取原来的值，并设置新的值"redis"127.0.0.1:6379> get db"mongodb"</code></pre><p>数据结构是相同的！</p><p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储！  </li></ul><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03%E3%80%91%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200609112628828.png" alt="List"></p><p>在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！</p><p>所有的list命令都是用l开头的，Redis不区分大小命令  </p><pre class=" language-bas"><code class="language-bas">##########################################################################127.0.0.1:6379> LPUSH list one # 将一个值或者多个值，插入到列表头部 （左）(integer) 1127.0.0.1:6379> LPUSH list two(integer) 2127.0.0.1:6379> LPUSH list three(integer) 3127.0.0.1:6379> LRANGE list 0 -1 # 获取list中值！1) "three"2) "two"3) "one"127.0.0.1:6379> LRANGE list 0 1 # 通过区间获取具体的值！1) "three"2) "two"127.0.0.1:6379> Rpush list righr # 将一个值或者多个值，插入到列表位部 （右）(integer) 4127.0.0.1:6379> LRANGE list 0 -11) "three"2) "two"3) "one"4) "righr"##########################################################################LPOPRPOP127.0.0.1:6379> LRANGE list 0 -11) "three"2) "two"3) "one"4) "righr"127.0.0.1:6379> Lpop list # 移除list的第一个元素"three"127.0.0.1:6379> Rpop list # 移除list的最后一个元素"righr"127.0.0.1:6379> LRANGE list 0 -11) "two"2) "one"##########################################################################Lindex127.0.0.1:6379> LRANGE list 0 -11) "two"2) "one"127.0.0.1:6379> lindex list 1 # 通过下标获得 list 中的某一个值！"one"127.0.0.1:6379> lindex list 0"two"##########################################################################Llen127.0.0.1:6379> Lpush list one(integer) 1127.0.0.1:6379> Lpush list two(integer) 2127.0.0.1:6379> Lpush list three(integer) 3127.0.0.1:6379> Llen list # 返回列表的长度(integer) 3##########################################################################移除指定的值！取关 uidLrem127.0.0.1:6379> LRANGE list 0 -11) "three"2) "three"3) "two"4) "one"127.0.0.1:6379> lrem list 1 one # 移除list集合中指定个数的value，精确匹配(integer) 1127.0.0.1:6379> LRANGE list 0 -11) "three"2) "three"3) "two"127.0.0.1:6379> lrem list 1 three(integer) 1127.0.0.1:6379> LRANGE list 0 -11) "three"2) "two"127.0.0.1:6379> Lpush list three(integer) 3127.0.0.1:6379> lrem list 2 three(integer) 2127.0.0.1:6379> LRANGE list 0 -11) "two"##########################################################################trim 修剪。； list 截断!127.0.0.1:6379> keys *(empty list or set)127.0.0.1:6379> Rpush mylist "hello"(integer) 1127.0.0.1:6379> Rpush mylist "hello1"(integer) 2127.0.0.1:6379> Rpush mylist "hello2"(integer) 3127.0.0.1:6379> Rpush mylist "hello3"(integer) 4127.0.0.1:6379> ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素！OK127.0.0.1:6379> LRANGE mylist 0 -11) "hello1"2) "hello2"##########################################################################rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中！127.0.0.1:6379> rpush mylist "hello"(integer) 1127.0.0.1:6379> rpush mylist "hello1"(integer) 2127.0.0.1:6379> rpush mylist "hello2"(integer) 3127.0.0.1:6379> rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的列表中！"hello2"127.0.0.1:6379> lrange mylist 0 -1 # 查看原来的列表1) "hello"2) "hello1"127.0.0.1:6379> lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！1) "hello2"##########################################################################lset 将列表中指定下标的值替换为另外一个值，更新操作127.0.0.1:6379> EXISTS list # 判断这个列表是否存在(integer) 0127.0.0.1:6379> lset list 0 item # 如果不存在列表我们去更新就会报错(error) ERR no such key127.0.0.1:6379> lpush list value1(integer) 1127.0.0.1:6379> LRANGE list 0 01) "value1"127.0.0.1:6379> lset list 0 item # 如果存在，更新当前下标的值OK127.0.0.1:6379> LRANGE list 0 01) "item"127.0.0.1:6379> lset list 1 other # 如果不存在，则会报错！(error) ERR index out of range##########################################################################linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面！127.0.0.1:6379> Rpush mylist "hello"(integer) 1127.0.0.1:6379> Rpush mylist "world"(integer) 2127.0.0.1:6379> LINSERT mylist before "world" "other"(integer) 3127.0.0.1:6379> LRANGE mylist 0 -11) "hello"2) "other"3) "world"127.0.0.1:6379> LINSERT mylist after world new(integer) 4127.0.0.1:6379> LRANGE mylist 0 -11) "hello"2) "other"3) "world"4) "new"</code></pre><blockquote><p>小结</p></blockquote><ul><li>他实际上是一个链表，before Node after ， left，right 都可以插入值</li><li>如果key 不存在，创建新的链表</li><li>如果key存在，新增内容  </li><li>如果移除了所有值，空链表，也代表不存在！</li><li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~  </li></ul><p>消息排队！消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！  </p><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>set中的值是不能重读的！  </p><pre class=" language-bas"><code class="language-bas">##########################################################################127.0.0.1:6379> sadd myset "hello" # set集合中添加匀速(integer) 1127.0.0.1:6379> sadd myset "lazyworm"(integer) 1127.0.0.1:6379> sadd myset "lovelazyworm"(integer) 1127.0.0.1:6379> SMEMBERS myset # 查看指定set的所有值1) "hello"2) "lovelazyworm"3) "lazyworm"127.0.0.1:6379> SISMEMBER myset hello # 判断某一个值是不是在set集合中！(integer) 1127.0.0.1:6379> SISMEMBER myset world(integer) 0##########################################################################127.0.0.1:6379> scard myset # 获取set集合中的内容元素个数！(integer) 4##########################################################################rem127.0.0.1:6379> srem myset hello # 移除set集合中的指定元素(integer) 1127.0.0.1:6379> scard myset(integer) 3127.0.0.1:6379> SMEMBERS myset1) "lovelazyworm2"2) "lovelazyworm"3) "lazyworm"##########################################################################set 无序不重复集合。抽随机！127.0.0.1:6379> SMEMBERS myset1) "lovelazyworm2"2) "lovelazyworm"3) "lazyworm"127.0.0.1:6379> SRANDMEMBER myset # 随机抽选出一个元素"lazyworm"127.0.0.1:6379> SRANDMEMBER myset"lazyworm"127.0.0.1:6379> SRANDMEMBER myset"lazyworm"127.0.0.1:6379> SRANDMEMBER myset"lazyworm"127.0.0.1:6379> SRANDMEMBER myset 2 # 随机抽选出指定个数的元素1) "lazyworm"2) "lazyworm2"127.0.0.1:6379> SRANDMEMBER myset 21) "lovelazyworm"2) "lazyworm2"127.0.0.1:6379> SRANDMEMBER myset # 随机抽选出一个元素"lazyworm2"##########################################################################删除定的key，随机删除key！127.0.0.1:6379> SMEMBERS myset1) "lovelazyworm2"2) "lovelazyworm"3) "lazyworm"127.0.0.1:6379> spop myset # 随机删除一些set集合中的元素！"lovelazyworm2"127.0.0.1:6379> spop myset"lovelazyworm"127.0.0.1:6379> SMEMBERS myset1) "lazyworm"##########################################################################将一个指定的值，移动到另外一个set集合！127.0.0.1:6379> sadd myset "hello"(integer) 1127.0.0.1:6379> sadd myset "world"(integer) 1127.0.0.1:6379> sadd myset "lazyworm"(integer) 1127.0.0.1:6379> sadd myset2 "set2"(integer) 1127.0.0.1:6379> smove myset myset2 "lazyworm" # 将一个指定的值，移动到另外一个set集合！(integer) 1127.0.0.1:6379> SMEMBERS myset1) "world"2) "hello"127.0.0.1:6379> SMEMBERS myset21) "lazyworm"2) "set2"##########################################################################微博，B站，共同关注！(并集)数字集合类：- 差集 SDIFF- 交集- 并集127.0.0.1:6379> SDIFF key1 key2 # 差集1) "b"2) "a"127.0.0.1:6379> SINTER key1 key2 # 交集 共同好友就可以这样实现1) "c"127.0.0.1:6379> SUNION key1 key2 # 并集1) "b"2) "c"3) "e"4) "a"5) "d"</code></pre><p>微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！</p><p>共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）  </p><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的<br>key-vlaue！</p><pre class=" language-bas"><code class="language-bas">##########################################################################127.0.0.1:6379> hset myhash field1 lazyworm # set一个具体 key-vlaue(integer) 1127.0.0.1:6379> hget myhash field1 # 获取一个字段值"lazyworm"127.0.0.1:6379> hmset myhash field1 hello field2 world # set多个 key-vlaueOK127.0.0.1:6379> hmget myhash field1 field2 # 获取多个字段值1) "hello"2) "world"127.0.0.1:6379> hgetall myhash # 获取全部的数据，1) "field1"2) "hello"3) "field2"4) "world"127.0.0.1:6379> hdel myhash field1 # 删除hash指定key字段！对应的value值也就消失了！(integer) 1127.0.0.1:6379> hgetall myhash1) "field2"2) "world"##########################################################################hlen127.0.0.1:6379> hmset myhash field1 hello field2 worldOK127.0.0.1:6379> HGETALL myhash1) "field2"2) "world"3) "field1"4) "hello"127.0.0.1:6379> hlen myhash # 获取hash表的字段数量！(integer) 2##########################################################################127.0.0.1:6379> HEXISTS myhash field1 # 判断hash中指定字段是否存在！(integer) 1127.0.0.1:6379> HEXISTS myhash field3(integer) 0########################################################################### 只获得所有field# 只获得所有value127.0.0.1:6379> hkeys myhash # 只获得所有field1) "field2"2) "field1"127.0.0.1:6379> hvals myhash # 只获得所有value1) "world"2) "hello"##########################################################################incr decr127.0.0.1:6379> hset myhash field3 5 #指定增量！(integer) 1127.0.0.1:6379> HINCRBY myhash field3 1(integer) 6127.0.0.1:6379> HINCRBY myhash field3 -1(integer) 5127.0.0.1:6379> hsetnx myhash field4 hello # 如果不存在则可以设置(integer) 1127.0.0.1:6379> hsetnx myhash field4 world # 如果存在则不能设置(integer) 0</code></pre><p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的<br>存储，String更加适合字符串存储！  </p><h2 id="Zset-有序集合）"><a href="#Zset-有序集合）" class="headerlink" title="Zset(有序集合）"></a>Zset(有序集合）</h2><p>在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> zadd myset 1 one # 添加一个值(integer) 1127.0.0.1:6379> zadd myset 2 two 3 three # 添加多个值(integer) 2127.0.0.1:6379> ZRANGE myset 0 -11) "one"2) "two"3) "three"##########################################################################排序如何实现127.0.0.1:6379> zadd salary 2500 xiaohong # 添加三个用户(integer) 1127.0.0.1:6379> zadd salary 5000 zhangsan(integer) 1127.0.0.1:6379> zadd salary 500 kaungshen(integer) 1# ZRANGEBYSCORE key min max127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 显示全部的用户 从小到大！1) "kaungshen"2) "xiaohong"3) "zhangsan"127.0.0.1:6379> ZREVRANGE salary 0 -1 # 从大到进行排序！1) "zhangsan"2) "kaungshen"127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成绩 1)"kaungshen"2) "500"3) "xiaohong"4) "2500"5) "zhangsan"6) "5000"127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于2500员工的升序排序！1) "kaungshen"2) "500"3) "xiaohong"4) "2500"########################################################################### 移除rem中的元素127.0.0.1:6379> zrange salary 0 -11) "kaungshen"2) "xiaohong"3) "zhangsan"127.0.0.1:6379> zrem salary xiaohong # 移除有序集合中的指定元素(integer) 1127.0.0.1:6379> zrange salary 0 -11) "kaungshen"2) "zhangsan"127.0.0.1:6379> zcard salary # 获取有序集合中的个数(integer) 2##########################################################################127.0.0.1:6379> zadd myset 1 hello(integer) 1127.0.0.1:6379> zadd myset 2 world 3 lazyworm(integer) 2127.0.0.1:6379> zcount myset 1 3 # 获取指定区间的成员数量！(integer) 3127.0.0.1:6379> zcount myset 1 2(integer) 2</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-02】Redis入门</title>
      <link href="/2020/06/02/redis-xue-xi-bi-ji-02-redis-ru-men/"/>
      <url>/2020/06/02/redis-xue-xi-bi-ji-02-redis-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Redis 是什么？  </p></blockquote><p>Redis（Remote Dictionary Server )，即远程字典服务 !</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，<br>并提供多种语言的API。  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608210233541.png" alt="Redis"></p><p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了<br>master-slave(主从)同步。<br>免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库  </p><blockquote><p>Redis能干嘛？</p></blockquote><p>1、内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</p><p>2、效率高，可以用于高速缓存</p><p>3、发布订阅系统</p><p>4、地图信息分析</p><p>5、计时器、计数器（浏览量！）</p><p>6、……..  </p><blockquote><p>特性</p></blockquote><p>1、多样的数据类型</p><p>2、持久化</p><p>3、集群</p><p>4、事务  </p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>1、启动redis服务！</p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608210740639.png" alt="启动redis服务"></p><p>2、使用redis-cli 进行连接测试！  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608210907101.png" alt="使用redis-cli 进行连接测试"></p><p>3、查看redis的进程是否开启！  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211017762.png" alt="查看redis的进程是否开启"></p><p>4、关闭Redis服务！</p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211104329.png" alt="关闭Redis服务"></p><p>5、再次查看进程是否存在  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211140632.png" alt="再次查看进程是否存在 "></p><h2 id="使用redis-benchmark-测试性能"><a href="#使用redis-benchmark-测试性能" class="headerlink" title="使用redis-benchmark  测试性能"></a>使用redis-benchmark  测试性能</h2><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211332415.png" alt="测试性能 性能参数"></p><p>我们来简单测试下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 测试：100个并发连接 100000请求</span>redis-benchmark -h localhost -p 6379 -c 100 -n 100000</code></pre><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211920414.png" alt="100个并发连接 100000请求"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608212033699.png" alt="redis默认有16个数据库  "></p><p>默认使用的是第0个<br>可以使用 select 进行切换数据库  </p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">select</span> 3 <span class="token comment" spellcheck="true"># 切换数据库</span>OK127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> DBSIZE <span class="token comment" spellcheck="true"># 查看DB大小！</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608212323735.png" alt="select 进行切换数据库"></p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> keys * <span class="token comment" spellcheck="true"># 查看数据库所有的key</span>1<span class="token punctuation">)</span> <span class="token string">"name"</span></code></pre><p>清除当前数据库 flushdb<br>清除全部数据库的内容 FLUSHALL  </p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> flushdbOK127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> keys *<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span></code></pre><h2 id="Redis是单线程的，但为什么这么快？"><a href="#Redis是单线程的，但为什么这么快？" class="headerlink" title="Redis是单线程的，但为什么这么快？"></a>Redis是单线程的，但为什么这么快？</h2><p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据<br>机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！</p><p>Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的<br>Memecache差！</p><blockquote><p> Redis 为什么单线程还这么快？</p></blockquote><p>1、误区1：高性能的服务器一定是多线程的？</p><p>2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p><p>先去CPU&gt;内存&gt;硬盘的速度要有所了解！</p><p>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程<br>（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高<br>的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-01】NoSQL概述</title>
      <link href="/2020/06/01/redis-xue-xi-bi-ji-01-nosql-gai-shu/"/>
      <url>/2020/06/01/redis-xue-xi-bi-ji-01-nosql-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h2><blockquote><p>1、Nosql概述  </p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E3%80%91NoSQL%E6%A6%82%E8%BF%B0/image-20200608181453244.png" alt="单机mysql"></p><p>90年代，一个基本的网站访问量一般不会太大，单个数据库完全足够！</p><p>那个时候，更多的去使用静态网页 Html ~ 服务器根本没有太大的压力！</p><p>思考一下，这种情况下：整个网站的瓶颈是什么？  </p><p>1、数据量如果太大、一个机器放不下了！</p><p>2、数据的索引 （B+ Tree），一个机器内存也放不下</p><p>3、访问量（读写混合），一个服务器承受不了~</p><p>只要你开始出现以上的三种情况之一，那么你就必须要晋级！  </p><blockquote><p>2、Memcached（缓存） + MySQL + 垂直拆分 （读写分离）  </p></blockquote><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压<br>力，我们可以使用缓存来保证效率！</p><p>发展过程： 优化数据结构和索引–&gt; 文件缓存（IO）—&gt; Memcached（当时最热门的技术！） </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E3%80%91NoSQL%E6%A6%82%E8%BF%B0/image-20200608190525349.png" alt="Memcached（缓存） + MySQL + 垂直拆分 （读写分离）"></p><blockquote><p>3、分库分表 + 水平拆分 + MySQL集群  </p></blockquote><p>技术和业务在发展的同时，对人的要求也越来越高！  </p><p>本质：数据库（读，写）</p><p>早些年MyISAM： 表锁，十分影响效率！高并发下就会出现严重的锁问题</p><p>转战Innodb：行锁</p><p>慢慢的就开始使用分库分表来解决写的压力！ MySQL 在那个年代推出 了表分区！这个并没有多少公司<br>使用！</p><p>MySQL 的 集群，很好满足那个年代的所有需求！  </p><blockquote><p>4、如今最近的年代  </p></blockquote><p>2010–2020 十年之间，世界已经发生了翻天覆地的变化；（定位，也是一种数据，音乐，热榜！）</p><p>MySQL 等关系型数据库就不够用了！数据量很多，变化很快~！</p><p>MySQL 有的使用它来村粗一些比较大的文件，博客，图片！数据库表很大，效率就低了！如果有一种数<br>据库来专门处理这种数据,</p><p>MySQL压力就变得十分小（研究如何处理这些问题！）大数据的IO压力下，表几乎没法更大！  </p><blockquote><p>目前一个基本的互联网项目！  </p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E3%80%91NoSQL%E6%A6%82%E8%BF%B0/image-20200608190832555.png" alt="基本互联网项目"></p><blockquote><p>为什么要用NoSQL！</p></blockquote><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！</p><p>这时候我们就需要使用NoSQL数据库的，Nosql 可以很好的处理以上的情况！  </p><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><blockquote><p>NoSQL</p></blockquote><p>NoSQL = Not Only SQL （不仅仅是SQL）<br>关系型数据库：表格 ，行 ，列<br>泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其<br>是超大规模的高并发的社区！ 暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅<br>速，Redis是发展最快的，而且是我们当下必须要掌握的一个技术！<br>很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！<br>不需要多月的操作就可以横向扩展的 ！ Map&lt;String,Object&gt; 使用键值对来控制！  </p><blockquote><p>NoSQL 特点  </p></blockquote><p>解耦！<br>1、方便扩展（数据之间没有关系，很好扩展！）<br>2、大数据量高性能（Redis 一秒写8万次，读取11万，NoSQL的缓存记录级，是一种细粒度的缓存，性<br>能会比较高！）<br>3、数据类型是多样型的！（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无<br>法设计了！）<br>4、传统 RDBMS 和 NoSQL  </p><pre class=" language-传统的"><code class="language-传统的">传统的 RDBMS- 结构化组织- SQL- 数据和关系都存在单独的表中 row col- 操作操作，数据定义语言- 严格的一致性- 基础的事务- .....</code></pre><pre><code>Nosql-不仅仅是数据- 没有固定的查询语言- 键值对存储，列存储，文档存储，图形数据库（社交关系）- 最终一致性，- CAP定理和BASE （异地多活） 初级架构师！- 高性能，高可用，高可扩- ...  ``</code></pre><p>大数据时代的3V：主要是描述问题的</p><ol><li>海量Volume</li><li>多样Variety</li><li>实时Velocity  </li></ol><p>大数据时代的3高：主要是对程序的要求</p><ol><li><p>高并发</p></li><li><p>高可扩</p></li><li><p>高性能  </p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-arguements解析</title>
      <link href="/2020/02/17/js-arguements-jie-xi/"/>
      <url>/2020/02/17/js-arguements-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象 arguments[0]，arguments.length</p><hr><p>#arguments是什么?</p><p>答: </p><p>1: arguments是收到的实参副本，在词法分析中, 首先按形参形成AO的属性,值为undefined<br>当实参传来时, 再修改AO的相应属性。</p><p>2: 并把所有收到实参收集起来,放到一个arguments对象里，t(a,b,c){},调用时: t(1,2,3,4,5) 5个参数，此时 , AO属性只有a,bc,3个属性, arguments里有1,2,3,4,5, 所有的值，对于超出形参个数之外的实参, 可以通过arguments来获得。</p><p>3: arguments 的索引 从 0, 1,2,….递增,与实参逐个对应。</p><p>4: arguments.length 属性代表实参的个数。</p><p>5: arguments一定不是数组, 是长的比较像数组的一个对象,虽然也有length属性。</p><p>6: arguments每个函数都会有,因此,arguemnts只会在内部找自身的arguments,无法引用到外层的arguments</p><pre><code>// 求圆形面积,矩形面积, 三角形面积function area () {    if(arguments.length == 1) {        alert(3.14 * arguments[0] * arguments[0]);    } else if(arguments.length == 2) {        alert(arguments[0] * arguments[1]);    } else if(arguments.length == 3) {        alert(arguments[0] + arguments[1] + arguments[2]);    } else {        return null;    }}area(10,20,30);</code></pre><p><a href="https://liangwenhao.cn/tags/arguements/" target="_blank" rel="noopener"># arguements</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jedis修改阿里云服务器配置</title>
      <link href="/2020/02/07/jdis-xiu-gai-a-li-yun-fu-wu-qi-pei-zhi/"/>
      <url>/2020/02/07/jdis-xiu-gai-a-li-yun-fu-wu-qi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>首先去阿里云添加安全组</p><p><img src="/images/jedis%E4%BF%AE%E6%94%B9%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/1.png" alt="阿里云添加安全组"></p><p>然后修改自己的redis配置文件</p><p><img src="/images/jedis%E4%BF%AE%E6%94%B9%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/2.png" alt="修改自己的redis配置"></p><p>重启redis服务即可</p><pre class=" language-bash"><code class="language-bash">redis-cli <span class="token function">shutdown</span> <span class="token comment" spellcheck="true">#关闭</span>redis-server /lazywormConif/redis.conf <span class="token comment" spellcheck="true">#启动</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> jedis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea快捷键</title>
      <link href="/2020/01/23/idea-kuai-jie-jian/"/>
      <url>/2020/01/23/idea-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<p>idea 快捷键</p><p>Ctrl + Alt + T 环绕用</p><p>Alt + Enter 导入包，自动修正代码 解决出现的问题 也可以生成返回值</p><p>Alt + Insert 定制生成类的各项基本方法</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows下部署Kubernetes</title>
      <link href="/2020/01/07/zai-windows-xia-bu-shu-kubernetes/"/>
      <url>/2020/01/07/zai-windows-xia-bu-shu-kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先去官网下载<strong>vagrant</strong>和<strong>VritualBox</strong>，<br>vagrant是一款用于创建和部署虚拟化开发环境的软件，而VritualBox就是虚拟机软件。</p><h1 id="【1-4】直接部署"><a href="#【1-4】直接部署" class="headerlink" title="【1-4】直接部署"></a>【1-4】直接部署</h1><p>以下4步我已经写好了vagrantfile文件，大家可以下载我上传的vagrantfile和setup.sh文件，然后直接运行</p><p><a href="https://github.com/wenhaoliang/Kubernetes">https://github.com/wenhaoliang/Kubernetes</a></p><pre class=" language-bash"><code class="language-bash">vagrant up</code></pre><p>就可以自动化的生成对应的一台master节点和三台worker节点</p><h1 id="5-安装Docker-kubelet-kubeadm-kubectl"><a href="#5-安装Docker-kubelet-kubeadm-kubectl" class="headerlink" title="5.安装Docker kubelet kubeadm kubectl"></a>5.安装Docker kubelet kubeadm kubectl</h1><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span>  <span class="token string">"deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main"</span> <span class="token operator">>></span> /etc/apt/sources.list<span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y docker.io apt-transport-https curl kubelet kubeadm kubectl --allow-unauthenticated</code></pre><h1 id="6-设置hosts"><a href="#6-设置hosts" class="headerlink" title="6.设置hosts"></a>6.设置hosts</h1><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"192.168.8.170 master1192.168.8.171 worker1192.168.8.172 worker2192.168.8.173 worker3"</span> <span class="token operator">>></span> /etc/hosts</code></pre><p>这里要把IP和主机名字改成自己的</p><h1 id="7-关闭swap和关闭防火墙"><a href="#7-关闭swap和关闭防火墙" class="headerlink" title="7.关闭swap和关闭防火墙"></a>7.关闭swap和关闭防火墙</h1><pre class=" language-bash"><code class="language-bash">swapoff -aufw disable</code></pre><p>接下来我们打开登陆自己的虚拟机，进入master节点</p><h1 id="8-在master节点进入root账户"><a href="#8-在master节点进入root账户" class="headerlink" title="8.在master节点进入root账户"></a>8.在master节点进入root账户</h1><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">passwd</span> root<span class="token function">su</span> root</code></pre><h1 id="9-初始化init"><a href="#9-初始化init" class="headerlink" title="9.初始化init"></a>9.初始化init</h1><pre class=" language-bash"><code class="language-bash">kubeadm init \--apiserver-advertise-address<span class="token operator">=</span>192.168.8.170 \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.15.0 \--service-cidr<span class="token operator">=</span>10.1.0.0/16 \--pod-network-cidr<span class="token operator">=</span>10.244.0.0/16</code></pre><p>这里会生成token，要记录下来，类似于</p><pre class=" language-bash"><code class="language-bash">kubeadm <span class="token function">join</span> 192.168.8.170:6443 --token ufocob.upw1fa0fqfiuxego \    --discovery-token-ca-cert-hash sha256:52011414517c40d3079c4ac5d8296f77d80a70b7c20ddbb69ddb73a4e8f9bf9b</code></pre><h1 id="10-添加flannel网络插件"><a href="#10-添加flannel网络插件" class="headerlink" title="10.添加flannel网络插件"></a>10.添加flannel网络插件</h1><pre class=" language-bas"><code class="language-bas">kubeadm join 192.168.8.170:6443 --token ufocob.upw1fa0fqfiuxego \    --discovery-token-ca-cert-hash sha256:52011414517c40d3079c4ac5d8296f77d80a70b7c20ddbb69ddb73a4e8f9bf9b</code></pre><p>部署到此结束</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kube-proxy解析</title>
      <link href="/2020/01/03/kube-proxy-jie-xi/"/>
      <url>/2020/01/03/kube-proxy-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Kubernetes 在每个节点上运行网络代理。这反映每个节点上 Kubernetes API 中定义的服务，并且可以做简单的 TCP 和 UDP 流转发或在一组后端中轮询，进行 TCP 和 UDP 转发。目前服务集群 IP 和端口通过由服务代理打开的端口 的 Docker-links-compatible 环境变量找到。有一个可选的为这些集群 IP 提供集群 DNS 的插件。用户必须 通过 apiserver API 创建服务去配置代理。</p><p>一、<strong>kube-proxy 监听 API server 中 service 和 endpoint 的变化情况，并通过 userspace、iptables、ipvs 或 winuserspace 等 proxier 来为服务配置负载均衡（仅支持 TCP 和 UDP）。</strong></p><p><img src="/images/Kube-proxy%E8%A7%A3%E6%9E%90/kube-proxy.png" alt="kube-proxy"></p><ul><li>kube-proxy 其实就是管理 Service 的访问入口，包括集群内 Pod 到 Service 的访问和集群外访问 Service；</li><li>kube-proxy 管理 Service 的 Endpoints，该 Service 对外暴露一个 Virtual IP，也称为 Cluster IP, 集群内通过访问这个 Cluster IP:Port 就能访问到集群内对应的 Serivce 下的 Pod；</li><li>Service 是通过 Selector 选择的一组 Pods 的服务抽象，其实就是一个微服务，提供了服务的 LB 和反向代理的能力，而 kube-proxy 的主要作用就是负责 Service 的实现；</li><li>Service 一个重要作用就是，一个服务后端的 Pods 可能会随着生存灭亡而发生 IP 的改变，Service 的出现，给服务提供了一个固定的 IP，而无视后端 Endpoint 的变化，而这种关联的维护主要依赖 kube-proxy 实现；</li></ul><h1 id="二、kube-proxy-内部原理"><a href="#二、kube-proxy-内部原理" class="headerlink" title="二、kube-proxy 内部原理"></a>二、kube-proxy 内部原理</h1><h1 id="kube-proxy-当前实现了三种代理模式：-userspace、iptables以及ipvs，但是最新的实现方式是ipvs方式。"><a href="#kube-proxy-当前实现了三种代理模式：-userspace、iptables以及ipvs，但是最新的实现方式是ipvs方式。" class="headerlink" title="kube-proxy 当前实现了三种代理模式：   userspace、iptables以及ipvs，但是最新的实现方式是ipvs方式。**"></a>kube-proxy 当前实现了三种代理模式：   <del>userspace、iptables</del>以及ipvs，但是最新的实现方式是ipvs方式。**</h1><h2 id="1、-userspace-模式"><a href="#1、-userspace-模式" class="headerlink" title="1、 userspace 模式"></a>1、 userspace 模式</h2><p>在这种模式下，kube-proxy 持续监听 Service 以及 Endpoints 对象的变化；对每个 Service，它都为其在本地节点开放一个端口，作为其服务代理端口；发往该端口的请求会采用一定的策略转发给与该服务对应的后端 Pod 实体。kube-proxy 同时会在本地节点设置 iptables 规则，配置一个 Virtual IP，把发往 Virtual IP 的请求重定向到与该 Virtual IP 对应的服务代理端口上。<br>其工作流程大体如下：<br><img src="images/Kube-proxy%E8%A7%A3%E6%9E%90/Userspace.png" alt="Userspace"></p><p>分析： 该模式请求在到达 iptables 进行处理时就会进入内核，而 kube-proxy 监听则是在用户态，请求就形成了从用户态到内核态再返回到用户态的传递过程，一定程度降低了服务性能。</p><h2 id="2、iptables-模式"><a href="#2、iptables-模式" class="headerlink" title="2、iptables 模式"></a>2、iptables 模式</h2><p>kube-proxy 持续监听 Service 以及 Endpoints 对象的变化；但它并不在本地节点开启反向代理服务，而是把反向代理全部交给 iptables 来实现；即 iptables 直接将对 VIP 的请求转发给后端 Pod，通过 iptables 设置转发策略。<br>其工作流程大体如下：<br><img src="images/Kube-proxy%E8%A7%A3%E6%9E%90/iptables.png" alt="iptables"></p><p>分析： 该模式相比 userspace 模式，克服了请求在用户态-内核态反复传递的问题，性能上有所提升，但使用 iptables NAT 来完成转发，存在不可忽视的性能损耗，而且在大规模场景下，iptables 规则的条目会十分巨大，性能上还要再打折扣。</p><h2 id="3、ipvs-模式"><a href="#3、ipvs-模式" class="headerlink" title="3、ipvs 模式"></a>3、ipvs 模式</h2><p>与 iptables、userspace 模式一样，kube-proxy 依然监听 Service 以及 Endpoints 对象的变化；不过它并不创建反向代理，也不创建大量的 iptables 规则；而是通过 netlink 创建 ipvs 规则，并使用 k8s Service 与 Endpoints 信息，对所在节点的 ipvs 规则进行定期同步；netlink 与 iptables 底层都是基于 netfilter 钩子，但是 netlink 由于采用了 hash table 而且直接工作在内核态，在性能上比 iptables 更优。</p><p><img src="images/Kube-proxy%E8%A7%A3%E6%9E%90/ipvs.png" alt="ipvs"></p><p>分析： ipvs 是目前 kube-proxy 所支持的最新代理模式，相比使用 iptables，使用 ipvs 具有更高的性能。</p><h1 id="三、ipvs"><a href="#三、ipvs" class="headerlink" title="三、ipvs"></a>三、ipvs</h1><p><strong>什么是 IPVS ?</strong></p><p>IPVS (IP Virtual Server)是在 Netfilter 上层构建的，并作为 Linux 内核的一部分，实现传输层负载均衡。</p><p>IPVS 集成在 LVS（Linux Virtual Server，Linux 虚拟服务器）中，它在主机上运行，并在物理服务器集群前作为负载均衡器。IPVS 可以将基于 TCP 和 UDP 服务的请求定向到真实服务器，并使真实服务器的服务在单个IP地址上显示为虚拟服务。 因此，IPVS 自然支持 Kubernetes 服务。</p><p><strong>为什么为 Kubernetes 选择 IPVS ?</strong></p><p>随着 Kubernetes 的使用增长，其资源的可扩展性变得越来越重要。特别是，服务的可扩展性对于运行大型工作负载的开发人员/公司采用 Kubernetes 至关重要。</p><p>Kube-proxy 是服务路由的构建块，它依赖于经过强化攻击的 iptables 来实现支持核心的服务类型，如 ClusterIP 和 NodePort。 但是，iptables 难以扩展到成千上万的服务，因为它纯粹是为防火墙而设计的，并且基于内核规则列表。</p><p>尽管 Kubernetes 在版本v1.6中已经支持5000个节点，但使用 iptables 的 kube-proxy 实际上是将集群扩展到5000个节点的瓶颈。 一个例子是，在5000节点集群中使用 NodePort 服务，如果我们有2000个服务并且每个服务有10个 pod，这将在每个工作节点上至少产生20000个 iptable 记录，这可能使内核非常繁忙。</p><p>另一方面，使用基于 IPVS 的集群内服务负载均衡可以为这种情况提供很多帮助。 IPVS 专门用于负载均衡，并使用更高效的数据结构（哈希表），允许几乎无限的规模扩张。</p><h1 id="三、ipvs原理"><a href="#三、ipvs原理" class="headerlink" title="三、ipvs原理"></a>三、ipvs原理</h1><p><strong>ipvs的模型中有两个角色：</strong></p><p>调度器:Director，又称为Balancer。 调度器主要用于接受用户请求。</p><p>真实主机:Real Server，简称为RS。用于真正处理用户的请求。</p><p><strong>IP地址类型分为三种：</strong></p><p>Client IP: 客户端请求源IP，简称CIP。</p><p>Director Virtual IP: 调度器用于与客户端通信的IP地址，简称为VIP。</p><p>Real Server IP:  后端主机的用于与调度器通信的IP地址，简称为RIP。</p><p><img src="images/Kube-proxy%E8%A7%A3%E6%9E%90/ipvs3.png" alt="ipvs3"></p><p><strong>工作过程：</strong></p><p>1、当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP。</p><p>2、PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链。</p><p>3、ipvs会监听到达input链的数据包，比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器IP，然后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP。</p><p>4、POSTROUTING链通过选路，将数据包发送给Real Server</p><p>5、Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP。</p><p>6、Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kube-proxy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
