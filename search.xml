<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快慢指针判断链表有环、寻找环入口、计算环大小的原理</title>
      <link href="/2020/06/14/kuai-man-zhi-zhen-pan-duan-lian-biao-you-huan-xun-zhao-huan-ru-kou-ji-suan-huan-da-xiao-de-yuan-li/"/>
      <url>/2020/06/14/kuai-man-zhi-zhen-pan-duan-lian-biao-you-huan-xun-zhao-huan-ru-kou-ji-suan-huan-da-xiao-de-yuan-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问题：</p></blockquote><pre><code>给定一个链表： 1. 判断链表是否有环。 2. 如果链表有环，请找出环入口。 3. 计算环的大小</code></pre><blockquote><p>思路：快慢指针</p></blockquote><p>​    分别定义一个快指针fast和慢指针slow，快指针一次走两步，慢指针一次走一步。如果链表没有环，那么fast最终会指向nullptr；如果链表有环，那么快指针和慢指针最终会相遇。所以，如果最终fast == nullptr，那么判断链表无环；如果最终fast == slow，且fast != nullptr，那么链表有环。</p><p><strong>1、第一步：快慢指针从头结点出发。如下图所示。蓝色表示快指针fast，红色表示慢指针slow。</strong></p><p><img src="/images/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E3%80%81%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E3%80%81%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8E%9F%E7%90%86/1.png" alt=""></p><p><strong>2、第二步：慢指针slow走到了环入口，共走了k步。此时快指针fast越过了环入口的步数为delta。因为快指针可能绕着环走了很多圈，所以有k == delta + n * R，其中R为环的大小，n为快指针绕环走的步数。</strong></p><p><img src="/images/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E3%80%81%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E3%80%81%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8E%9F%E7%90%86/2.png" alt=""></p><p><strong>3、第三步：慢指针进入环中。因为快指针每次都比慢指针快一步，所以，快慢指针最后一定会相遇。【证明了必然会相遇】</strong></p><p><strong>4、第四步：计算快慢指针相遇位置。因为慢指针在刚进入环时距离快指针delta步，所以快指针还需要比慢指针多走R - delta步才能与慢指针相遇。又因为快指针每次走两步，所以快指针还需要走2(R - delta)步。那么，相遇位置为2(R - delta) + delta == 2R - delta，即，距离环入口delta处，与慢指针刚进入环时快指针所在位置对称。</strong></p><p><img src="/images/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E3%80%81%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E3%80%81%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8E%9F%E7%90%86/3.png" alt=""></p><p>5、第五步：快指针重新从头结点开始走，速度为一次一步，与慢指针相同。可知，快指针走到环入口时，所需步数为k。刚好，k == delta + n * R，这也是慢指针在环中所走的距离。由快慢指针在环中的相遇位置可知，慢指针此时刚好走到了环入口，并与快指针相遇，此时，找到了环入口。【证明了能找到环入口。】</p><p><img src="/images/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E3%80%81%E5%AF%BB%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3%E3%80%81%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8E%9F%E7%90%86/4.png" alt=""></p><p>6、第六步：如何求环大小。这个相对简单，在证明链表是否有环的过程中，快慢指针第一次相遇。此后，快指针继续按一次两步的速度走，慢指针按一次一步的速度走，并设置一个计数器count = 0，每走一次加1,。当快慢指针再次相遇时，快指针刚好比慢指针多走了R步，而计数器count == R。【计算了环大小】</p><pre><code>寻找环入口LLNode * LinkedList::entranceOfLoop(){    LLNode * slow = pHead;    LLNode * fast = pHead;    while(fast &amp;&amp; fast-&gt;pNext){        fast = fast-&gt;pNext-&gt;pNext;        slow = slow-&gt;pNext;        if(fast == slow) break;    }    if(!fast || !fast-&gt;pNext) {        return nullptr;    }    fast = pHead;    while(fast != slow){        fast = fast-&gt;pNext;        slow = slow-&gt;pNext;    }    return fast;}</code></pre><pre><code>计算环大小int LinkedList::sizeOfLoop(){    LLNode * slow = pHead;    LLNode * fast = pHead;    while(fast &amp;&amp; fast-&gt;pNext){        fast = fast-&gt;pNext-&gt;pNext;        slow = pNext;        if(fast == slow) break;    }    if(!fast || !fast-&gt;pNext) {        return 0;    }    int size = 1;    fast = fast-&gt;pNext-&gt;pNext;    slow = slow-&gt;pNext;    while(fast != slow){        ++size;        fast = fast-&gt;pNext-&gt;pNext;        slow = slow-&gt;pNext;    }    return size;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-09】缓存穿透和雪崩</title>
      <link href="/2020/06/08/redis-xue-xi-bi-ji-09-huan-cun-chuan-tou-he-xue-beng/"/>
      <url>/2020/06/08/redis-xue-xi-bi-ji-09-huan-cun-chuan-tou-he-xue-beng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>服务的高可用问题 </p></blockquote><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一<br>些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据<br>的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-09%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/image-20200609151558257.png" alt="缓存穿透"></p><h1 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h1><blockquote><p>概念</p></blockquote><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于<br>是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒<br>杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了<br>缓存穿透。</p><blockquote><p>解决方案</p></blockquote><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则<br>丢弃，从而避免了对底层存储系统的查询压力；</p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-09%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/2.png" alt="布隆过滤器"></p><p> 缓存空对象</p><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数<br>据将会从缓存中获取，保护了后端数据源；  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-09%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/3.png" alt=" 缓存空对象"></p><p>但是这种方法会存在两个问题：</p><p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多<br>的空值的键；</p><p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于<br>需要保持一致性的业务会有影响。</p><h2 id="缓存击穿（量太大，缓存过期！）"><a href="#缓存击穿（量太大，缓存过期！）" class="headerlink" title="缓存击穿（量太大，缓存过期！）"></a>缓存击穿（量太大，缓存过期！）</h2><blockquote><p>概述</p></blockquote><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中<br>对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一<br>个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访<br>问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><blockquote><p>解决方案</p></blockquote><p><strong>设置热点数据永不过期</strong></p><p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p><p><strong>加互斥锁</strong></p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布<br>式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考<br>验很大。</p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-09%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/image-20200609152904435.png" alt="缓存击穿"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote><p>概念</p></blockquote><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p><p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商<br>品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都<br>过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波<br>峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-09%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/4.png" alt="缓存雪崩"></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然<br>形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就<br>是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知<br>的，很有可能瞬间就把数据库压垮。</p><blockquote><p>解决方案  </p></blockquote><p><strong>redis高可用</strong></p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续<br>工作，其实就是搭建的集群。（异地多活！）</p><p><strong>限流降级（在SpringCloud讲解过！）</strong></p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对<br>某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>数据预热</strong></p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数<br>据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让<br>缓存失效的时间点尽量均匀。  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-08】持久化</title>
      <link href="/2020/06/07/redis-xue-xi-bi-ji-08-chi-jiu-hua/"/>
      <url>/2020/06/07/redis-xue-xi-bi-ji-08-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中<br>的数据库状态也会消失。所以 Redis 提供了持久化功能！  </p><h1 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h1><blockquote><p>什么是RDB  </p></blockquote><p>在主从复制中，rdb就是备用了！从机上面！  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96/image-20200609145751884.png" alt="RDB"></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快<br>照文件直接读到内存里。</p><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程<br>都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。<br>这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那<br>RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是<br>RDB，一般情况下不需要修改这个配置！</p><p>有时候在生产环境我们会将这个文件进行备份！</p><p>rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96/image-20200609145843982.png" alt="dump"></p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96/image-20200609145940179.png" alt="save"></p><blockquote><p>触发机制</p></blockquote><p>1、save的规则满足的情况下，会自动触发rdb规则</p><p>2、执行 flushall 命令，也会触发我们的rdb规则！</p><p>3、退出redis，也会产生 rdb 文件！</p><p>备份就自动生成一个 dump.rdb  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96/image-20200609150049864.png" alt=" dump.rdb  "></p><blockquote><p>如果恢复rdb文件！</p></blockquote><p>1、只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中<br>的数据！</p><p>2、查看需要存在的位置  </p><pre class=" language-bsah"><code class="language-bsah">如果恢复rdb文件！1、只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！2、查看需要存在的位置</code></pre><p>优点：</p><ol><li>适合大规模的数据恢复！</li><li>对数据的完整性要不高！</li></ol><p>缺点：</p><ol><li>需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！</li><li>fork进程的时候，会占用一定的内容空间！！  </li></ol><h1 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h1><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96/image-20200609150253032.png" alt="AOF"></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件<br>但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件<br>的内容将写指令从前到后执行一次以完成数据的恢复工作</p><p><strong>Aof保存的是 appendonly.aof 文件</strong></p><blockquote><p>append  </p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96/image-20200609150412424.png" alt="appendonly.aof"></p><p>默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！</p><p>重启，redis 就可以生效了！</p><p>如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件</p><p>redis 给我们提供了一个工具 <strong>redis-check-aof –fix</strong>  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96/image-20200609150936161.png" alt="**redis-check-aof --fix** "></p><p>如果文件正常，重启就可以直接恢复了！  </p><blockquote><p>重写规则说明  </p></blockquote><p><strong>aof 默认就是文件的无限追加，文件会越来越大！</strong>  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-08%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96/image-20200609151131536.png" alt="**aof "></p><p>如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！  </p><blockquote><p>优点和缺点！  </p></blockquote><pre class=" language-bash"><code class="language-bash">appendonly no <span class="token comment" spellcheck="true"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，</span>rdb完全够用！appendfilename <span class="token string">"appendonly.aof"</span> <span class="token comment" spellcheck="true"># 持久化的文件的名字</span><span class="token comment" spellcheck="true"># appendfsync always # 每次修改都会 sync。消耗性能</span>appendfsync everysec <span class="token comment" spellcheck="true"># 每秒执行一次 sync，可能会丢失这1s的数据！</span><span class="token comment" spellcheck="true"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span><span class="token comment" spellcheck="true"># rewrite 重写，</span></code></pre><p>优点：</p><p>1、每一次修改都同步，文件的完整会更加好！</p><p>2、每秒同步一次，可能会丢失一秒的数据</p><p>3、从不同步，效率最高的！</p><p>缺点：</p><p>1、相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</p><p>2、Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化！</p><p>扩展：</p><p>1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p><p>2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始<br>的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重<br>写，使得AOF文件的体积不至于过大。</p><p>3、<strong>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</strong></p><p>4、同时开启两种持久化方式</p><ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF<br>文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者<br>建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有<br>AOF可能潜在的Bug，留着作为一个万一的手段。</li></ul><p>5、性能建议</p><ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够<br>了，只保留 save 900 1 这条规则。</li><li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自<br>己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产<br>生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite<br>的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重<br>写可以改到适当的数值。</li><li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也<br>减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，<br>启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。  </li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-06】SpringBoot整合</title>
      <link href="/2020/06/06/redis-xue-xi-bi-ji-06-springboot-zheng-he/"/>
      <url>/2020/06/06/redis-xue-xi-bi-ji-06-springboot-zheng-he/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p><p>SpringData 也是和 SpringBoot 齐名的项目！</p><p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p><p>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接<br>池！ 更像 BIO 模式</p><p>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据<br>了，更像 NIO 模式</p><p>源码分析：  </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"redisTemplate"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 我们可以自己定义一个</span>redisTemplate来替换这个默认的！<span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactoryredisConnectionFactory<span class="token punctuation">)</span>    <span class="token keyword">throws</span> UnknownHostException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span>    <span class="token comment" spellcheck="true">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object></span>    RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> template<span class="token punctuation">;</span><span class="token punctuation">}</span> @Bean<span class="token annotation punctuation">@ConditionalOnMissingBean</span> <span class="token comment" spellcheck="true">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一</span>个bean！<span class="token keyword">public</span> StringRedisTemplate <span class="token function">stringRedisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactoryredisConnectionFactory<span class="token punctuation">)</span>    <span class="token keyword">throws</span> UnknownHostException <span class="token punctuation">{</span>    StringRedisTemplate template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> template<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>整合测试一下  </p><p>1、导入依赖  </p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 操作redis <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span><span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>data<span class="token operator">-</span>redis<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>2、配置连接  </p><pre class=" language-java"><code class="language-java"># 配置redisspring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>host<span class="token operator">=</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">6379</span></code></pre><p>3、测试！  </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Redis02SpringbootApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span>        <span class="token comment" spellcheck="true">// opsForValue 操作字符串 类似String</span>        <span class="token comment" spellcheck="true">// opsForList 操作List 类似List</span>        <span class="token comment" spellcheck="true">// opsForSet</span>        <span class="token comment" spellcheck="true">// opsForHash</span>        <span class="token comment" spellcheck="true">// opsForZSet</span>        <span class="token comment" spellcheck="true">// opsForGeo</span>        <span class="token comment" spellcheck="true">// opsForHyperLogLog</span>        <span class="token comment" spellcheck="true">// 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的</span>        CRUD        <span class="token comment" spellcheck="true">// 获取redis的连接对象</span>        <span class="token comment" spellcheck="true">// RedisConnection connection =</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">getConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// connection.flushDb();</span>        <span class="token comment" spellcheck="true">// connection.flushAll();</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"mykey"</span><span class="token punctuation">,</span><span class="token string">"关注狂神说公众号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"mykey"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们来编写一个自己的 RedisTemplete  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>lazy<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>JsonAutoDetect<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PropertyAccessor<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>ObjectMapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>RedisConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RedisTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>Jackson2JsonRedisSerializer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>StringRedisSerializer<span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 自己定义了一个 RedisTemplate</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactory    factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 我们为了自己开发方便，一般直接使用 &lt;String, Object></span>        RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>        Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Json序列化配置</span>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectMapper om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>PropertyAccessor<span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> JsonAutoDetect<span class="token punctuation">.</span>Visibility<span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span>ObjectMapper<span class="token punctuation">.</span>DefaultTyping<span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// String 的序列化</span>        StringRedisSerializer stringRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span>        <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// key采用String的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash的key也采用String的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// value序列化方式采用jackson</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash的value序列化方式采用jackson</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数<br>据结构的用处和作用场景！  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-07】Redis.conf详解</title>
      <link href="/2020/06/06/redis-xue-xi-bi-ji-07-redis.conf-xiang-jie-fu-ben/"/>
      <url>/2020/06/06/redis-xue-xi-bi-ji-07-redis.conf-xiang-jie-fu-ben/</url>
      
        <content type="html"><![CDATA[<p>启动的时候，就通过配置文件来启动！</p><p>工作中，一些小小的配置，可以让你脱颖而出！</p><blockquote><p>单位</p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07%E3%80%91Redis.conf%E8%AF%A6%E8%A7%A3/image-20200609144438472.png" alt="单位"></p><p>1、配置文件 unit单位 对大小写不敏感！  </p><blockquote><p>包含</p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-07%E3%80%91Redis.conf%E8%AF%A6%E8%A7%A3/image-20200609145315708.png" alt="包含"></p><blockquote><p>网络  </p></blockquote><pre class=" language-bas"><code class="language-bas">bind 127.0.0.1 # 绑定的ipprotected-mode yes # 保护模式port 6379 # 端口设置</code></pre><blockquote><p>通用 GENERAL  </p></blockquote><pre class=" language-bash"><code class="language-bash">daemonize <span class="token function">yes</span> <span class="token comment" spellcheck="true"># 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！</span>pidfile /var/run/redis_6379.pid <span class="token comment" spellcheck="true"># 如果以后台的方式运行，我们就需要指定一个 pid 文件！</span><span class="token comment" spellcheck="true"># 日志</span><span class="token comment" spellcheck="true"># Specify the server verbosity level.</span><span class="token comment" spellcheck="true"># This can be one of:</span><span class="token comment" spellcheck="true"># debug (a lot of information, useful for development/testing)</span><span class="token comment" spellcheck="true"># verbose (many rarely useful info, but not a mess like the debug level)</span><span class="token comment" spellcheck="true"># notice (moderately verbose, what you want in production probably) 生产环境</span><span class="token comment" spellcheck="true"># warning (only very important / critical messages are logged)</span>loglevel noticelogfile <span class="token string">""</span> <span class="token comment" spellcheck="true"># 日志的文件位置名</span>databases 16 <span class="token comment" spellcheck="true"># 数据库的数量，默认是 16 个数据库</span>always-show-logo <span class="token function">yes</span> <span class="token comment" spellcheck="true"># 是否总是显示LOGO</span></code></pre><blockquote><p>快照</p></blockquote><p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof</p><p>redis 是内存数据库，如果没有持久化，那么数据断电及失！  </p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span>save 900 1<span class="token comment" spellcheck="true"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span>save 300 10<span class="token comment" spellcheck="true"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span>save 60 10000<span class="token comment" spellcheck="true"># 我们之后学习持久化，会自己定义这个测试！</span>stop-writes-on-bgsave-error <span class="token function">yes</span> <span class="token comment" spellcheck="true"># 持久化如果出错，是否还需要继续工作！</span>rdbcompression <span class="token function">yes</span> <span class="token comment" spellcheck="true"># 是否压缩 rdb 文件，需要消耗一些cpu资源！</span>rdbchecksum <span class="token function">yes</span> <span class="token comment" spellcheck="true"># 保存rdb文件的时候，进行错误的检查校验！</span><span class="token function">dir</span> ./ <span class="token comment" spellcheck="true"># rdb 文件保存的目录！</span></code></pre><blockquote><p>SECURITY 安全  </p></blockquote><p>可以在这里设置redis的密码，默认是没有密码！  </p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> <span class="token function">ping</span>PONG127.0.0.1:6379<span class="token operator">></span> config get requirepass <span class="token comment" spellcheck="true"># 获取redis的密码</span>1<span class="token punctuation">)</span> <span class="token string">"requirepass"</span>2<span class="token punctuation">)</span> <span class="token string">""</span>127.0.0.1:6379<span class="token operator">></span> config <span class="token keyword">set</span> requirepass <span class="token string">"123456"</span> <span class="token comment" spellcheck="true"># 设置redis的密码</span>OK127.0.0.1:6379<span class="token operator">></span> config get requirepass <span class="token comment" spellcheck="true"># 发现所有的命令都没有权限了</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> NOAUTH Authentication required.127.0.0.1:6379<span class="token operator">></span> <span class="token function">ping</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> NOAUTH Authentication required.127.0.0.1:6379<span class="token operator">></span> auth 123456 <span class="token comment" spellcheck="true"># 使用密码进行登录！</span>OK127.0.0.1:6379<span class="token operator">></span> config get requirepass1<span class="token punctuation">)</span> <span class="token string">"requirepass"</span>2<span class="token punctuation">)</span> <span class="token string">"123456"</span></code></pre><blockquote><p>限制 CLIENTS  </p></blockquote><pre class=" language-bash"><code class="language-bash">maxclients 10000 <span class="token comment" spellcheck="true"># 设置能连接上redis的最大客户端的数量</span>maxmemory <span class="token operator">&lt;</span>bytes<span class="token operator">></span> <span class="token comment" spellcheck="true"># redis 配置最大的内存容量</span>maxmemory-policy noeviction <span class="token comment" spellcheck="true"># 内存到达上限之后的处理策略</span>    1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）    2、allkeys-lru ： 删除lru算法的key    3、volatile-random：随机删除即将过期key    4、allkeys-random：随机删除    5、volatile-ttl ： 删除即将过期的    6、noeviction ： 永不过期，返回错误</code></pre><blockquote><p>APPEND ONLY 模式 aof配置  </p></blockquote><pre class=" language-bash"><code class="language-bash">appendonly no <span class="token comment" spellcheck="true"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，</span>rdb完全够用！appendfilename <span class="token string">"appendonly.aof"</span> <span class="token comment" spellcheck="true"># 持久化的文件的名字</span><span class="token comment" spellcheck="true"># appendfsync always # 每次修改都会 sync。消耗性能</span>appendfsync everysec <span class="token comment" spellcheck="true"># 每秒执行一次 sync，可能会丢失这1s的数据！</span><span class="token comment" spellcheck="true"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-04】三种特殊数据类型</title>
      <link href="/2020/06/05/redis-xue-xi-bi-ji-04-san-chong-te-shu-shu-ju-lei-xing/"/>
      <url>/2020/06/05/redis-xue-xi-bi-ji-04-san-chong-te-shu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h1><p>朋友的定位，附近的人，打车距离计算？</p><p>Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆<br>几里的人！</p><p>可以查询一些测试数据：<a href="http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/" target="_blank" rel="noopener">http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/</a></p><p>只有 六个命令：  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04%E3%80%91%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200609113454185.png" alt="Geospatial 地理位置  六个命令"></p><p>官方文档：<a href="https://www.redis.net.cn/order/3685.html" target="_blank" rel="noopener">https://www.redis.net.cn/order/3685.html</a>  </p><blockquote><p>getadd</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># getadd 添加地理位置</span><span class="token comment" spellcheck="true"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</span><span class="token comment" spellcheck="true"># 有效的经度从-180度到180度。</span><span class="token comment" spellcheck="true"># 有效的纬度从-85.05112878度到85.05112878度。</span><span class="token comment" spellcheck="true"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span><span class="token comment" spellcheck="true"># 127.0.0.1:6379> geoadd china:city 39.90 116.40 beijin</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR invalid longitude,latitude pair 39.900000,116.400000<span class="token comment" spellcheck="true"># 参数 key 值（）</span>127.0.0.1:6379<span class="token operator">></span> geoadd china:city 116.40 39.90 beijing<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> geoadd china:city 121.47 31.23 shanghai<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2127.0.0.1:6379<span class="token operator">></span> geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre><blockquote><p>getpods</p></blockquote><pre class=" language-bas"><code class="language-bas">#获得当前定位：一定是一个坐标值！127.0.0.1:6379> GEOPOS china:city beijing # 获取指定的城市的经度和纬度！1) 1) "116.39999896287918091"2) "39.90000009167092543"127.0.0.1:6379> GEOPOS china:city beijing chongqi1) 1) "116.39999896287918091"2) "39.90000009167092543"2) 1) "106.49999767541885376"2) "29.52999957900659211"</code></pre><blockquote><p>GEODIST</p></blockquote><p>两人之间的距离！</p><p>单位：</p><p>m 表示单位为米。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> GEODIST china:city beijing shanghai km # 查看上海到北京的直线距离"1067.3788"127.0.0.1:6379> GEODIST china:city beijing chongqi km # 查看重庆到北京的直线距离"1464.0708"</code></pre><blockquote><p>georadius 以给定的经纬度为中心， 找出某一半径内的元素  </p></blockquote><p>我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！</p><p>获得指定数量的人，200</p><p>所有数据应该都录入：china:city ，才会让结果更加请求！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> GEORADIUS china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻找方圆1000km内的城市1) "chongqi"2) "xian"3) "shengzhen"4) "hangzhou"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km1) "chongqi"2) "xian"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist # 显示到中间距离的位置1) 1) "chongqi"2) "341.9374"2) 1) "xian"2) "483.8340"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息1) 1) "chongqi"2) 1) "106.49999767541885376"2) "29.52999957900659211"2) 1) "xian"2) 1) "108.96000176668167114"2) "34.25999964418929977"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist withcoord count 1 #筛选出指定的结果！1) 1) "chongqi"2) "341.9374"3) 1) "106.49999767541885376"2) "29.52999957900659211"127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist withcoord count 21) 1) "chongqi"2) "341.9374"3) 1) "106.49999767541885376"2) "29.52999957900659211"2) 1) "xian"2) "483.8340"3) 1) "108.96000176668167114"2) "34.25999964418929977"</code></pre><blockquote><p>GEORADIUSBYMEMBER  </p></blockquote><pre class=" language-ba"><code class="language-ba"># 找出位于指定元素周围的其他元素！127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing 1000 km1) "beijing"2) "xian"127.0.0.1:6379> GEORADIUSBYMEMBER china:city shanghai 400 km1) "hangzhou"2) "shanghai"</code></pre><blockquote><p>GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示  </p></blockquote><p>该命令将返回11个字符的Geohash字符串!  </p><pre class=" language-bas"><code class="language-bas"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！127.0.0.1:6379> geohash china:city beijing chongqi1) "wx4fbxxfke0"2) "wm5xzrybty0"</code></pre><blockquote><p>GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！  </p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> ZRANGE china:city 0 -1 # 查看地图中全部的元素1) "chongqi"2) "xian"3) "shengzhen"4) "hangzhou"5) "shanghai"6) "beijing"127.0.0.1:6379> zrem china:city beijing # 移除指定元素！(integer) 1127.0.0.1:6379> ZRANGE china:city 0 -11) "chongqi"2) "xian"3) "shengzhen"4) "hangzhou"5) "shanghai"</code></pre><h1 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h1><blockquote><p>什么是基数？</p></blockquote><p>A {1,3,5,7,8,7}</p><p>B{1,3,5,7,8}</p><p>基数（不重复的元素） = 5，可以接受误差！</p><blockquote><p>简介</p></blockquote><p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p><p>Redis Hyperloglog 基数统计的算法！  </p><p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的<br>话 Hyperloglog 首选！</p><p><strong>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</strong></p><p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !</p><p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p><p>0.81% 错误率！ 统计UV任务，可以忽略不计的  </p><blockquote><p>测试使用</p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey(integer) 1127.0.0.1:6379> PFCOUNT mykey # 统计 mykey 元素的基数数量(integer) 10127.0.0.1:6379> PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2(integer) 1127.0.0.1:6379> PFCOUNT mykey2(integer) 9127.0.0.1:6379> PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 => mykey3 并集OK127.0.0.1:6379> PFCOUNT mykey3 # 看并集的数量！(integer) 15</code></pre><p>如果允许容错，那么一定可以使用 Hyperloglog ！</p><p>如果不允许容错，就使用 set 或者自己的数据类型即可！  </p><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><blockquote><p>位存储</p></blockquote><p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用<br>Bitmaps！</p><p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！</p><p>365 天 = 365 bit 1字节 = 8bit 46 个字节左右！  </p><blockquote><p>测试</p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04%E3%80%91%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200609114206489.png" alt="Bitmap "></p><p>使用bitmap 来记录 周一到周日的打卡！</p><p>周一：1 周二：0 周三：0 周四：1 ……  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-04%E3%80%91%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200609114250548.png" alt="周一到周日的打卡"></p><p>查看某一天是否有打卡！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> getbit sign 3(integer) 1127.0.0.1:6379> getbit sign 6(integer) 0</code></pre><p>统计操作，统计 打卡的天数！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！(integer) 3</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-05】事务</title>
      <link href="/2020/06/05/redis-xue-xi-bi-ji-05-shi-wu/"/>
      <url>/2020/06/05/redis-xue-xi-bi-ji-05-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按<br>照顺序执行！</p><p>一次性、顺序性、排他性！执行一些列的命令！  </p><pre class=" language-bas"><code class="language-bas">------ 队列 set set set 执行------</code></pre><p><strong>Redis事务没有没有隔离级别的概念！</strong></p><p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec</p><p><strong>Redis单条命令式保存原子性的，但是事务不保证原子性！</strong></p><p>redis的事务：</p><ul><li>开启事务（multi）</li><li>命令入队（……）</li><li>执行事务（exec）</li></ul><blockquote><p>正常执行事务！</p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> multi # 开启事务OK# 命令入队127.0.0.1:6379> set k1 v1QUEUED127.0.0.1:6379> set k2 v2QUEUED127.0.0.1:6379> get k2QUEUED127.0.0.1:6379> set k3 v3QUEUED127.0.0.1:6379> exec # 执行事务1) OK2) OK3) "v2"4) OK</code></pre><blockquote><p>放弃事务！  </p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> multi # 开启事务OK127.0.0.1:6379> set k1 v1QUEUED127.0.0.1:6379> set k2 v2QUEUED127.0.0.1:6379> set k4 v4QUEUED127.0.0.1:6379> DISCARD # 取消事务OK127.0.0.1:6379> get k4 # 事务队列中命令都不会被执行！(nil)</code></pre><blockquote><p> 编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！</p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> multiOK127.0.0.1:6379> set k1 v1QUEUED127.0.0.1:6379> set k2 v2QUEUED127.0.0.1:6379> set k3 v3QUEUED127.0.0.1:6379> getset k3 # 错误的命令(error) ERR wrong number of arguments for 'getset' command127.0.0.1:6379> set k4 v4QUEUED127.0.0.1:6379> set k5 v5QUEUED127.0.0.1:6379> exec # 执行事务报错！(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379> get k5 # 所有的命令都不会被执行！(nil)</code></pre><blockquote><p> 运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！  </p></blockquote><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> set k1 "v1"OK127.0.0.1:6379> multiOK127.0.0.1:6379> incr k1 # 会执行的时候失败！QUEUED127.0.0.1:6379> set k2 v2QUEUED127.0.0.1:6379> set k3 v3QUEUED127.0.0.1:6379> get k3QUEUED127.0.0.1:6379> exec1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！2) OK3) OK4) "v3"127.0.0.1:6379> get k2"v2"127.0.0.1:6379> get k3"v3"</code></pre><blockquote><p>*<em>监控！ Watch （面试常问！）  *</em></p></blockquote><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否<br>有人修改过这个数据，</li><li>获取version</li><li>更新的时候比较 version  </li></ul><blockquote><p>Redis测监视测试  </p></blockquote><p>  正常执行成功！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> set money 100OK127.0.0.1:6379> set out 0OK127.0.0.1:6379> watch money # 监视 money 对象OK127.0.0.1:6379> multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！OK127.0.0.1:6379> DECRBY money 20QUEUED127.0.0.1:6379> INCRBY out 20QUEUED127.0.0.1:6379> exec1) (integer) 802) (integer) 20</code></pre><p>测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> watch money # 监视 moneyOK127.0.0.1:6379> multiOK127.0.0.1:6379> DECRBY money 10QUEUED127.0.0.1:6379> INCRBY out 10QUEUED127.0.0.1:6379> exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！(nil)</code></pre><p>如果修改失败，获取最新的值就好  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> UNWATCH #如果发现事务执行失败，就先解锁OK127.0.0.1:6379> watch money #获取最新的值，再次监视，select versionOK127.0.0.1:6379> multiQUEUED127.0.0.1:6379> DECRBY money 1QUEUED127.0.0.1:6379> INCRBY money 1QUEUED127.0.0.1:6379> exec #对比监视的值师傅发生了变化，如果没有变化，就可以执行成功，如果发生了变化就执行失败1)(integer) 9991)(integer) 1000</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-03】五大数据类型</title>
      <link href="/2020/06/03/redis-xue-xi-bi-ji-03-wu-da-shu-ju-lei-xing/"/>
      <url>/2020/06/03/redis-xue-xi-bi-ji-03-wu-da-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> keys * # 查看所有的key(empty list or set)127.0.0.1:6379> set name lazyworm # set keyOK127.0.0.1:6379> keys *1) "name"127.0.0.1:6379> set age 1OK127.0.0.1:6379> keys *1) "age"2) "name"127.0.0.1:6379> EXISTS name # 判断当前的key是否存在(integer) 1127.0.0.1:6379> EXISTS name1(integer) 0127.0.0.1:6379> move name 1 # 移除当前的key(integer) 1127.0.0.1:6379> keys *1) "age"127.0.0.1:6379> set name lazywormOK127.0.0.1:6379> keys *1) "age"2) "name"127.0.0.1:6379> clear127.0.0.1:6379> keys *1) "age"2) "name"127.0.0.1:6379> get name"lazyworm"127.0.0.1:6379> EXPIRE name 10 # 设置key的过期时间，单位是秒(integer) 1127.0.0.1:6379> ttl name # 查看当前key的剩余时间(integer) 4127.0.0.1:6379> ttl name(integer) 3127.0.0.1:6379> ttl name(integer) 2127.0.0.1:6379> ttl name(integer) 1127.0.0.1:6379> ttl name(integer) -2127.0.0.1:6379> get name(nil)127.0.0.1:6379> type name # 查看当前key的一个类型！string127.0.0.1:6379> type agestring</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre class=" language-ba"><code class="language-ba">##########################################################################127.0.0.1:6379> set key1 v1 # 设置值OK127.0.0.1:6379> get key1 # 获得值"v1"127.0.0.1:6379> keys * # 获得所有的key1) "key1"127.0.0.1:6379> EXISTS key1 # 判断某一个key是否存在(integer) 1127.0.0.1:6379> APPEND key1 "hello" # 追加字符串，如果当前key不存在，就相当于setkey(integer) 7127.0.0.1:6379> get key1"v1hello"127.0.0.1:6379> STRLEN key1 # 获取字符串的长度！(integer) 7127.0.0.1:6379> APPEND key1 ",lazyworm"(integer) 17127.0.0.1:6379> STRLEN key1(integer) 17127.0.0.1:6379> get key1"v1hello,lazyworm"########################################################################### i++# 步长 i+=127.0.0.1:6379> set views 0 # 初始浏览量为0OK127.0.0.1:6379> get views"0"127.0.0.1:6379> incr views # 自增1 浏览量变为1(integer) 1127.0.0.1:6379> incr views(integer) 2127.0.0.1:6379> get views"2"127.0.0.1:6379> decr views # 自减1 浏览量-1(integer) 1127.0.0.1:6379> decr views(integer) 0127.0.0.1:6379> decr views(integer) -1127.0.0.1:6379> get views"-1"127.0.0.1:6379> INCRBY views 10 # 可以设置步长，指定增量！(integer) 9127.0.0.1:6379> INCRBY views 10(integer) 19127.0.0.1:6379> DECRBY views 5(integer) 14########################################################################### 字符串范围 range127.0.0.1:6379> set key1 "hello,lazyworm" # 设置 key1 的值OK127.0.0.1:6379> get key1"hello,lazyworm"127.0.0.1:6379> GETRANGE key1 0 3 # 截取字符串 [0,3]"hell"127.0.0.1:6379> GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的"hello,lazyworm"# 替换！127.0.0.1:6379> set key2 abcdefgOK127.0.0.1:6379> get key2"abcdefg"127.0.0.1:6379> SETRANGE key2 1 xx # 替换指定位置开始的字符串！(integer) 7127.0.0.1:6379> get key2"axxdefg"########################################################################### setex (set with expire) # 设置过期时间# setnx (set if not exist) # 不存在在设置 （在分布式锁中会常常使用！）127.0.0.1:6379> setex key3 30 "hello" # 设置key3 的值为 hello,30秒后过期OK127.0.0.1:6379> ttl key3(integer) 26127.0.0.1:6379> get key3"hello"127.0.0.1:6379> setnx mykey "redis" # 如果mykey 不存在，创建mykey(integer) 1127.0.0.1:6379> keys *1) "key2"2) "mykey"3) "key1"127.0.0.1:6379> ttl key3(integer) -2127.0.0.1:6379> setnx mykey "MongoDB" # 如果mykey存在，创建失败！(integer) 0127.0.0.1:6379> get mykey"redis"##########################################################################msetmget127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3 # 同时设置多个值OK127.0.0.1:6379> keys *1) "k1"2) "k2"3) "k3"127.0.0.1:6379> mget k1 k2 k3 # 同时获取多个值1) "v1"2) "v2"3) "v3"127.0.0.1:6379> msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起失败！(integer) 0127.0.0.1:6379> get k4(nil)# 对象set user:1 {name:zhangsan,age:3} # 设置一个user:1 对象 值为 json字符来保存一个对象！# 这里的key是一个巧妙的设计： user:{id}:{filed} , 如此设计在Redis中是完全OK了！127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379> mget user:1:name user:1:age1) "zhangsan"2) "2"##########################################################################getset # 先get然后在set127.0.0.1:6379> getset db redis # 如果不存在值，则返回 nil(nil)127.0.0.1:6379> get db"redis127.0.0.1:6379> getset db mongodb # 如果存在值，获取原来的值，并设置新的值"redis"127.0.0.1:6379> get db"mongodb"</code></pre><p>数据结构是相同的！</p><p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储！  </li></ul><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03%E3%80%91%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20200609112628828.png" alt="List"></p><p>在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！</p><p>所有的list命令都是用l开头的，Redis不区分大小命令  </p><pre class=" language-bas"><code class="language-bas">##########################################################################127.0.0.1:6379> LPUSH list one # 将一个值或者多个值，插入到列表头部 （左）(integer) 1127.0.0.1:6379> LPUSH list two(integer) 2127.0.0.1:6379> LPUSH list three(integer) 3127.0.0.1:6379> LRANGE list 0 -1 # 获取list中值！1) "three"2) "two"3) "one"127.0.0.1:6379> LRANGE list 0 1 # 通过区间获取具体的值！1) "three"2) "two"127.0.0.1:6379> Rpush list righr # 将一个值或者多个值，插入到列表位部 （右）(integer) 4127.0.0.1:6379> LRANGE list 0 -11) "three"2) "two"3) "one"4) "righr"##########################################################################LPOPRPOP127.0.0.1:6379> LRANGE list 0 -11) "three"2) "two"3) "one"4) "righr"127.0.0.1:6379> Lpop list # 移除list的第一个元素"three"127.0.0.1:6379> Rpop list # 移除list的最后一个元素"righr"127.0.0.1:6379> LRANGE list 0 -11) "two"2) "one"##########################################################################Lindex127.0.0.1:6379> LRANGE list 0 -11) "two"2) "one"127.0.0.1:6379> lindex list 1 # 通过下标获得 list 中的某一个值！"one"127.0.0.1:6379> lindex list 0"two"##########################################################################Llen127.0.0.1:6379> Lpush list one(integer) 1127.0.0.1:6379> Lpush list two(integer) 2127.0.0.1:6379> Lpush list three(integer) 3127.0.0.1:6379> Llen list # 返回列表的长度(integer) 3##########################################################################移除指定的值！取关 uidLrem127.0.0.1:6379> LRANGE list 0 -11) "three"2) "three"3) "two"4) "one"127.0.0.1:6379> lrem list 1 one # 移除list集合中指定个数的value，精确匹配(integer) 1127.0.0.1:6379> LRANGE list 0 -11) "three"2) "three"3) "two"127.0.0.1:6379> lrem list 1 three(integer) 1127.0.0.1:6379> LRANGE list 0 -11) "three"2) "two"127.0.0.1:6379> Lpush list three(integer) 3127.0.0.1:6379> lrem list 2 three(integer) 2127.0.0.1:6379> LRANGE list 0 -11) "two"##########################################################################trim 修剪。； list 截断!127.0.0.1:6379> keys *(empty list or set)127.0.0.1:6379> Rpush mylist "hello"(integer) 1127.0.0.1:6379> Rpush mylist "hello1"(integer) 2127.0.0.1:6379> Rpush mylist "hello2"(integer) 3127.0.0.1:6379> Rpush mylist "hello3"(integer) 4127.0.0.1:6379> ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素！OK127.0.0.1:6379> LRANGE mylist 0 -11) "hello1"2) "hello2"##########################################################################rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中！127.0.0.1:6379> rpush mylist "hello"(integer) 1127.0.0.1:6379> rpush mylist "hello1"(integer) 2127.0.0.1:6379> rpush mylist "hello2"(integer) 3127.0.0.1:6379> rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的列表中！"hello2"127.0.0.1:6379> lrange mylist 0 -1 # 查看原来的列表1) "hello"2) "hello1"127.0.0.1:6379> lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！1) "hello2"##########################################################################lset 将列表中指定下标的值替换为另外一个值，更新操作127.0.0.1:6379> EXISTS list # 判断这个列表是否存在(integer) 0127.0.0.1:6379> lset list 0 item # 如果不存在列表我们去更新就会报错(error) ERR no such key127.0.0.1:6379> lpush list value1(integer) 1127.0.0.1:6379> LRANGE list 0 01) "value1"127.0.0.1:6379> lset list 0 item # 如果存在，更新当前下标的值OK127.0.0.1:6379> LRANGE list 0 01) "item"127.0.0.1:6379> lset list 1 other # 如果不存在，则会报错！(error) ERR index out of range##########################################################################linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面！127.0.0.1:6379> Rpush mylist "hello"(integer) 1127.0.0.1:6379> Rpush mylist "world"(integer) 2127.0.0.1:6379> LINSERT mylist before "world" "other"(integer) 3127.0.0.1:6379> LRANGE mylist 0 -11) "hello"2) "other"3) "world"127.0.0.1:6379> LINSERT mylist after world new(integer) 4127.0.0.1:6379> LRANGE mylist 0 -11) "hello"2) "other"3) "world"4) "new"</code></pre><blockquote><p>小结</p></blockquote><ul><li>他实际上是一个链表，before Node after ， left，right 都可以插入值</li><li>如果key 不存在，创建新的链表</li><li>如果key存在，新增内容  </li><li>如果移除了所有值，空链表，也代表不存在！</li><li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~  </li></ul><p>消息排队！消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！  </p><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>set中的值是不能重读的！  </p><pre class=" language-bas"><code class="language-bas">##########################################################################127.0.0.1:6379> sadd myset "hello" # set集合中添加匀速(integer) 1127.0.0.1:6379> sadd myset "lazyworm"(integer) 1127.0.0.1:6379> sadd myset "lovelazyworm"(integer) 1127.0.0.1:6379> SMEMBERS myset # 查看指定set的所有值1) "hello"2) "lovelazyworm"3) "lazyworm"127.0.0.1:6379> SISMEMBER myset hello # 判断某一个值是不是在set集合中！(integer) 1127.0.0.1:6379> SISMEMBER myset world(integer) 0##########################################################################127.0.0.1:6379> scard myset # 获取set集合中的内容元素个数！(integer) 4##########################################################################rem127.0.0.1:6379> srem myset hello # 移除set集合中的指定元素(integer) 1127.0.0.1:6379> scard myset(integer) 3127.0.0.1:6379> SMEMBERS myset1) "lovelazyworm2"2) "lovelazyworm"3) "lazyworm"##########################################################################set 无序不重复集合。抽随机！127.0.0.1:6379> SMEMBERS myset1) "lovelazyworm2"2) "lovelazyworm"3) "lazyworm"127.0.0.1:6379> SRANDMEMBER myset # 随机抽选出一个元素"lazyworm"127.0.0.1:6379> SRANDMEMBER myset"lazyworm"127.0.0.1:6379> SRANDMEMBER myset"lazyworm"127.0.0.1:6379> SRANDMEMBER myset"lazyworm"127.0.0.1:6379> SRANDMEMBER myset 2 # 随机抽选出指定个数的元素1) "lazyworm"2) "lazyworm2"127.0.0.1:6379> SRANDMEMBER myset 21) "lovelazyworm"2) "lazyworm2"127.0.0.1:6379> SRANDMEMBER myset # 随机抽选出一个元素"lazyworm2"##########################################################################删除定的key，随机删除key！127.0.0.1:6379> SMEMBERS myset1) "lovelazyworm2"2) "lovelazyworm"3) "lazyworm"127.0.0.1:6379> spop myset # 随机删除一些set集合中的元素！"lovelazyworm2"127.0.0.1:6379> spop myset"lovelazyworm"127.0.0.1:6379> SMEMBERS myset1) "lazyworm"##########################################################################将一个指定的值，移动到另外一个set集合！127.0.0.1:6379> sadd myset "hello"(integer) 1127.0.0.1:6379> sadd myset "world"(integer) 1127.0.0.1:6379> sadd myset "lazyworm"(integer) 1127.0.0.1:6379> sadd myset2 "set2"(integer) 1127.0.0.1:6379> smove myset myset2 "lazyworm" # 将一个指定的值，移动到另外一个set集合！(integer) 1127.0.0.1:6379> SMEMBERS myset1) "world"2) "hello"127.0.0.1:6379> SMEMBERS myset21) "lazyworm"2) "set2"##########################################################################微博，B站，共同关注！(并集)数字集合类：- 差集 SDIFF- 交集- 并集127.0.0.1:6379> SDIFF key1 key2 # 差集1) "b"2) "a"127.0.0.1:6379> SINTER key1 key2 # 交集 共同好友就可以这样实现1) "c"127.0.0.1:6379> SUNION key1 key2 # 并集1) "b"2) "c"3) "e"4) "a"5) "d"</code></pre><p>微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！</p><p>共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）  </p><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的<br>key-vlaue！</p><pre class=" language-bas"><code class="language-bas">##########################################################################127.0.0.1:6379> hset myhash field1 lazyworm # set一个具体 key-vlaue(integer) 1127.0.0.1:6379> hget myhash field1 # 获取一个字段值"lazyworm"127.0.0.1:6379> hmset myhash field1 hello field2 world # set多个 key-vlaueOK127.0.0.1:6379> hmget myhash field1 field2 # 获取多个字段值1) "hello"2) "world"127.0.0.1:6379> hgetall myhash # 获取全部的数据，1) "field1"2) "hello"3) "field2"4) "world"127.0.0.1:6379> hdel myhash field1 # 删除hash指定key字段！对应的value值也就消失了！(integer) 1127.0.0.1:6379> hgetall myhash1) "field2"2) "world"##########################################################################hlen127.0.0.1:6379> hmset myhash field1 hello field2 worldOK127.0.0.1:6379> HGETALL myhash1) "field2"2) "world"3) "field1"4) "hello"127.0.0.1:6379> hlen myhash # 获取hash表的字段数量！(integer) 2##########################################################################127.0.0.1:6379> HEXISTS myhash field1 # 判断hash中指定字段是否存在！(integer) 1127.0.0.1:6379> HEXISTS myhash field3(integer) 0########################################################################### 只获得所有field# 只获得所有value127.0.0.1:6379> hkeys myhash # 只获得所有field1) "field2"2) "field1"127.0.0.1:6379> hvals myhash # 只获得所有value1) "world"2) "hello"##########################################################################incr decr127.0.0.1:6379> hset myhash field3 5 #指定增量！(integer) 1127.0.0.1:6379> HINCRBY myhash field3 1(integer) 6127.0.0.1:6379> HINCRBY myhash field3 -1(integer) 5127.0.0.1:6379> hsetnx myhash field4 hello # 如果不存在则可以设置(integer) 1127.0.0.1:6379> hsetnx myhash field4 world # 如果存在则不能设置(integer) 0</code></pre><p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的<br>存储，String更加适合字符串存储！  </p><h2 id="Zset-有序集合）"><a href="#Zset-有序集合）" class="headerlink" title="Zset(有序集合）"></a>Zset(有序集合）</h2><p>在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1  </p><pre class=" language-bas"><code class="language-bas">127.0.0.1:6379> zadd myset 1 one # 添加一个值(integer) 1127.0.0.1:6379> zadd myset 2 two 3 three # 添加多个值(integer) 2127.0.0.1:6379> ZRANGE myset 0 -11) "one"2) "two"3) "three"##########################################################################排序如何实现127.0.0.1:6379> zadd salary 2500 xiaohong # 添加三个用户(integer) 1127.0.0.1:6379> zadd salary 5000 zhangsan(integer) 1127.0.0.1:6379> zadd salary 500 kaungshen(integer) 1# ZRANGEBYSCORE key min max127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 显示全部的用户 从小到大！1) "kaungshen"2) "xiaohong"3) "zhangsan"127.0.0.1:6379> ZREVRANGE salary 0 -1 # 从大到进行排序！1) "zhangsan"2) "kaungshen"127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成绩 1)"kaungshen"2) "500"3) "xiaohong"4) "2500"5) "zhangsan"6) "5000"127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于2500员工的升序排序！1) "kaungshen"2) "500"3) "xiaohong"4) "2500"########################################################################### 移除rem中的元素127.0.0.1:6379> zrange salary 0 -11) "kaungshen"2) "xiaohong"3) "zhangsan"127.0.0.1:6379> zrem salary xiaohong # 移除有序集合中的指定元素(integer) 1127.0.0.1:6379> zrange salary 0 -11) "kaungshen"2) "zhangsan"127.0.0.1:6379> zcard salary # 获取有序集合中的个数(integer) 2##########################################################################127.0.0.1:6379> zadd myset 1 hello(integer) 1127.0.0.1:6379> zadd myset 2 world 3 lazyworm(integer) 2127.0.0.1:6379> zcount myset 1 3 # 获取指定区间的成员数量！(integer) 3127.0.0.1:6379> zcount myset 1 2(integer) 2</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-02】Redis入门</title>
      <link href="/2020/06/02/redis-xue-xi-bi-ji-02-redis-ru-men/"/>
      <url>/2020/06/02/redis-xue-xi-bi-ji-02-redis-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Redis 是什么？  </p></blockquote><p>Redis（Remote Dictionary Server )，即远程字典服务 !</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，<br>并提供多种语言的API。  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608210233541.png" alt="Redis"></p><p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了<br>master-slave(主从)同步。<br>免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库  </p><blockquote><p>Redis能干嘛？</p></blockquote><p>1、内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</p><p>2、效率高，可以用于高速缓存</p><p>3、发布订阅系统</p><p>4、地图信息分析</p><p>5、计时器、计数器（浏览量！）</p><p>6、……..  </p><blockquote><p>特性</p></blockquote><p>1、多样的数据类型</p><p>2、持久化</p><p>3、集群</p><p>4、事务  </p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>1、启动redis服务！</p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608210740639.png" alt="启动redis服务"></p><p>2、使用redis-cli 进行连接测试！  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608210907101.png" alt="使用redis-cli 进行连接测试"></p><p>3、查看redis的进程是否开启！  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211017762.png" alt="查看redis的进程是否开启"></p><p>4、关闭Redis服务！</p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211104329.png" alt="关闭Redis服务"></p><p>5、再次查看进程是否存在  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211140632.png" alt="再次查看进程是否存在 "></p><h2 id="使用redis-benchmark-测试性能"><a href="#使用redis-benchmark-测试性能" class="headerlink" title="使用redis-benchmark  测试性能"></a>使用redis-benchmark  测试性能</h2><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211332415.png" alt="测试性能 性能参数"></p><p>我们来简单测试下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 测试：100个并发连接 100000请求</span>redis-benchmark -h localhost -p 6379 -c 100 -n 100000</code></pre><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608211920414.png" alt="100个并发连接 100000请求"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库  </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608212033699.png" alt="redis默认有16个数据库  "></p><p>默认使用的是第0个<br>可以使用 select 进行切换数据库  </p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">select</span> 3 <span class="token comment" spellcheck="true"># 切换数据库</span>OK127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> DBSIZE <span class="token comment" spellcheck="true"># 查看DB大小！</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E3%80%91Redis%E5%85%A5%E9%97%A8/image-20200608212323735.png" alt="select 进行切换数据库"></p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> keys * <span class="token comment" spellcheck="true"># 查看数据库所有的key</span>1<span class="token punctuation">)</span> <span class="token string">"name"</span></code></pre><p>清除当前数据库 flushdb<br>清除全部数据库的内容 FLUSHALL  </p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> flushdbOK127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> keys *<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span></code></pre><h2 id="Redis是单线程的，但为什么这么快？"><a href="#Redis是单线程的，但为什么这么快？" class="headerlink" title="Redis是单线程的，但为什么这么快？"></a>Redis是单线程的，但为什么这么快？</h2><p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据<br>机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！</p><p>Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的<br>Memecache差！</p><blockquote><p> Redis 为什么单线程还这么快？</p></blockquote><p>1、误区1：高性能的服务器一定是多线程的？</p><p>2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p><p>先去CPU&gt;内存&gt;硬盘的速度要有所了解！</p><p>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程<br>（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高<br>的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis学习笔记-01】NoSQL概述</title>
      <link href="/2020/06/01/redis-xue-xi-bi-ji-01-nosql-gai-shu/"/>
      <url>/2020/06/01/redis-xue-xi-bi-ji-01-nosql-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h2><blockquote><p>1、Nosql概述  </p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E3%80%91NoSQL%E6%A6%82%E8%BF%B0/image-20200608181453244.png" alt="单机mysql"></p><p>90年代，一个基本的网站访问量一般不会太大，单个数据库完全足够！</p><p>那个时候，更多的去使用静态网页 Html ~ 服务器根本没有太大的压力！</p><p>思考一下，这种情况下：整个网站的瓶颈是什么？  </p><p>1、数据量如果太大、一个机器放不下了！</p><p>2、数据的索引 （B+ Tree），一个机器内存也放不下</p><p>3、访问量（读写混合），一个服务器承受不了~</p><p>只要你开始出现以上的三种情况之一，那么你就必须要晋级！  </p><blockquote><p>2、Memcached（缓存） + MySQL + 垂直拆分 （读写分离）  </p></blockquote><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压<br>力，我们可以使用缓存来保证效率！</p><p>发展过程： 优化数据结构和索引–&gt; 文件缓存（IO）—&gt; Memcached（当时最热门的技术！） </p><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E3%80%91NoSQL%E6%A6%82%E8%BF%B0/image-20200608190525349.png" alt="Memcached（缓存） + MySQL + 垂直拆分 （读写分离）"></p><blockquote><p>3、分库分表 + 水平拆分 + MySQL集群  </p></blockquote><p>技术和业务在发展的同时，对人的要求也越来越高！  </p><p>本质：数据库（读，写）</p><p>早些年MyISAM： 表锁，十分影响效率！高并发下就会出现严重的锁问题</p><p>转战Innodb：行锁</p><p>慢慢的就开始使用分库分表来解决写的压力！ MySQL 在那个年代推出 了表分区！这个并没有多少公司<br>使用！</p><p>MySQL 的 集群，很好满足那个年代的所有需求！  </p><blockquote><p>4、如今最近的年代  </p></blockquote><p>2010–2020 十年之间，世界已经发生了翻天覆地的变化；（定位，也是一种数据，音乐，热榜！）</p><p>MySQL 等关系型数据库就不够用了！数据量很多，变化很快~！</p><p>MySQL 有的使用它来村粗一些比较大的文件，博客，图片！数据库表很大，效率就低了！如果有一种数<br>据库来专门处理这种数据,</p><p>MySQL压力就变得十分小（研究如何处理这些问题！）大数据的IO压力下，表几乎没法更大！  </p><blockquote><p>目前一个基本的互联网项目！  </p></blockquote><p><img src="/images/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E3%80%91NoSQL%E6%A6%82%E8%BF%B0/image-20200608190832555.png" alt="基本互联网项目"></p><blockquote><p>为什么要用NoSQL！</p></blockquote><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！</p><p>这时候我们就需要使用NoSQL数据库的，Nosql 可以很好的处理以上的情况！  </p><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><blockquote><p>NoSQL</p></blockquote><p>NoSQL = Not Only SQL （不仅仅是SQL）<br>关系型数据库：表格 ，行 ，列<br>泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其<br>是超大规模的高并发的社区！ 暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅<br>速，Redis是发展最快的，而且是我们当下必须要掌握的一个技术！<br>很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！<br>不需要多月的操作就可以横向扩展的 ！ Map&lt;String,Object&gt; 使用键值对来控制！  </p><blockquote><p>NoSQL 特点  </p></blockquote><p>解耦！<br>1、方便扩展（数据之间没有关系，很好扩展！）<br>2、大数据量高性能（Redis 一秒写8万次，读取11万，NoSQL的缓存记录级，是一种细粒度的缓存，性<br>能会比较高！）<br>3、数据类型是多样型的！（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无<br>法设计了！）<br>4、传统 RDBMS 和 NoSQL  </p><pre class=" language-传统的"><code class="language-传统的">传统的 RDBMS- 结构化组织- SQL- 数据和关系都存在单独的表中 row col- 操作操作，数据定义语言- 严格的一致性- 基础的事务- .....</code></pre><pre><code>Nosql-不仅仅是数据- 没有固定的查询语言- 键值对存储，列存储，文档存储，图形数据库（社交关系）- 最终一致性，- CAP定理和BASE （异地多活） 初级架构师！- 高性能，高可用，高可扩- ...  ``</code></pre><p>大数据时代的3V：主要是描述问题的</p><ol><li>海量Volume</li><li>多样Variety</li><li>实时Velocity  </li></ol><p>大数据时代的3高：主要是对程序的要求</p><ol><li><p>高并发</p></li><li><p>高可扩</p></li><li><p>高性能  </p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-arguements解析</title>
      <link href="/2020/02/17/js-arguements-jie-xi/"/>
      <url>/2020/02/17/js-arguements-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象 arguments[0]，arguments.length</p><hr><p>#arguments是什么?</p><p>答: </p><p>1: arguments是收到的实参副本，在词法分析中, 首先按形参形成AO的属性,值为undefined<br>当实参传来时, 再修改AO的相应属性。</p><p>2: 并把所有收到实参收集起来,放到一个arguments对象里，t(a,b,c){},调用时: t(1,2,3,4,5) 5个参数，此时 , AO属性只有a,bc,3个属性, arguments里有1,2,3,4,5, 所有的值，对于超出形参个数之外的实参, 可以通过arguments来获得。</p><p>3: arguments 的索引 从 0, 1,2,….递增,与实参逐个对应。</p><p>4: arguments.length 属性代表实参的个数。</p><p>5: arguments一定不是数组, 是长的比较像数组的一个对象,虽然也有length属性。</p><p>6: arguments每个函数都会有,因此,arguemnts只会在内部找自身的arguments,无法引用到外层的arguments</p><pre><code>// 求圆形面积,矩形面积, 三角形面积function area () {    if(arguments.length == 1) {        alert(3.14 * arguments[0] * arguments[0]);    } else if(arguments.length == 2) {        alert(arguments[0] * arguments[1]);    } else if(arguments.length == 3) {        alert(arguments[0] + arguments[1] + arguments[2]);    } else {        return null;    }}area(10,20,30);</code></pre><p><a href="https://liangwenhao.cn/tags/arguements/" target="_blank" rel="noopener"># arguements</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jedis修改阿里云服务器配置</title>
      <link href="/2020/02/07/jdis-xiu-gai-a-li-yun-fu-wu-qi-pei-zhi/"/>
      <url>/2020/02/07/jdis-xiu-gai-a-li-yun-fu-wu-qi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>首先去阿里云添加安全组</p><p><img src="/images/jedis%E4%BF%AE%E6%94%B9%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/1.png" alt="阿里云添加安全组"></p><p>然后修改自己的redis配置文件</p><p><img src="/images/jedis%E4%BF%AE%E6%94%B9%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/2.png" alt="修改自己的redis配置"></p><p>重启redis服务即可</p><pre class=" language-bash"><code class="language-bash">redis-cli <span class="token function">shutdown</span> <span class="token comment" spellcheck="true">#关闭</span>redis-server /lazywormConif/redis.conf <span class="token comment" spellcheck="true">#启动</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> jedis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea快捷键</title>
      <link href="/2020/01/23/idea-kuai-jie-jian/"/>
      <url>/2020/01/23/idea-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<p>idea 快捷键</p><p>Ctrl + Alt + T 环绕用</p><p>Alt + Enter 导入包，自动修正代码 解决出现的问题 也可以生成返回值</p><p>Alt + Insert 定制生成类的各项基本方法</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows下部署Kubernetes</title>
      <link href="/2020/01/07/zai-windows-xia-bu-shu-kubernetes/"/>
      <url>/2020/01/07/zai-windows-xia-bu-shu-kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先去官网下载<strong>vagrant</strong>和<strong>VritualBox</strong>，<br>vagrant是一款用于创建和部署虚拟化开发环境的软件，而VritualBox就是虚拟机软件。</p><h1 id="【1-4】直接部署"><a href="#【1-4】直接部署" class="headerlink" title="【1-4】直接部署"></a>【1-4】直接部署</h1><p>以下4步我已经写好了vagrantfile文件，大家可以下载我上传的vagrantfile和setup.sh文件，然后直接运行</p><p><a href="https://github.com/wenhaoliang/Kubernetes">https://github.com/wenhaoliang/Kubernetes</a></p><pre class=" language-bash"><code class="language-bash">vagrant up</code></pre><p>就可以自动化的生成对应的一台master节点和三台worker节点</p><h1 id="5-安装Docker-kubelet-kubeadm-kubectl"><a href="#5-安装Docker-kubelet-kubeadm-kubectl" class="headerlink" title="5.安装Docker kubelet kubeadm kubectl"></a>5.安装Docker kubelet kubeadm kubectl</h1><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span>  <span class="token string">"deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main"</span> <span class="token operator">>></span> /etc/apt/sources.list<span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y docker.io apt-transport-https curl kubelet kubeadm kubectl --allow-unauthenticated</code></pre><h1 id="6-设置hosts"><a href="#6-设置hosts" class="headerlink" title="6.设置hosts"></a>6.设置hosts</h1><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"192.168.8.170 master1192.168.8.171 worker1192.168.8.172 worker2192.168.8.173 worker3"</span> <span class="token operator">>></span> /etc/hosts</code></pre><p>这里要把IP和主机名字改成自己的</p><h1 id="7-关闭swap和关闭防火墙"><a href="#7-关闭swap和关闭防火墙" class="headerlink" title="7.关闭swap和关闭防火墙"></a>7.关闭swap和关闭防火墙</h1><pre class=" language-bash"><code class="language-bash">swapoff -aufw disable</code></pre><p>接下来我们打开登陆自己的虚拟机，进入master节点</p><h1 id="8-在master节点进入root账户"><a href="#8-在master节点进入root账户" class="headerlink" title="8.在master节点进入root账户"></a>8.在master节点进入root账户</h1><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">passwd</span> root<span class="token function">su</span> root</code></pre><h1 id="9-初始化init"><a href="#9-初始化init" class="headerlink" title="9.初始化init"></a>9.初始化init</h1><pre class=" language-bash"><code class="language-bash">kubeadm init \--apiserver-advertise-address<span class="token operator">=</span>192.168.8.170 \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.15.0 \--service-cidr<span class="token operator">=</span>10.1.0.0/16 \--pod-network-cidr<span class="token operator">=</span>10.244.0.0/16</code></pre><p>这里会生成token，要记录下来，类似于</p><pre class=" language-bash"><code class="language-bash">kubeadm <span class="token function">join</span> 192.168.8.170:6443 --token ufocob.upw1fa0fqfiuxego \    --discovery-token-ca-cert-hash sha256:52011414517c40d3079c4ac5d8296f77d80a70b7c20ddbb69ddb73a4e8f9bf9b</code></pre><h1 id="10-添加flannel网络插件"><a href="#10-添加flannel网络插件" class="headerlink" title="10.添加flannel网络插件"></a>10.添加flannel网络插件</h1><pre class=" language-bas"><code class="language-bas">kubeadm join 192.168.8.170:6443 --token ufocob.upw1fa0fqfiuxego \    --discovery-token-ca-cert-hash sha256:52011414517c40d3079c4ac5d8296f77d80a70b7c20ddbb69ddb73a4e8f9bf9b</code></pre><p>部署到此结束</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/01/07/test/"/>
      <url>/2020/01/07/test/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先去官网下载<strong>vagrant</strong>和<strong>VritualBox</strong>，<br>vagrant是一款用于创建和部署虚拟化开发环境的软件，而VritualBox就是虚拟机软件。</p><h1 id="【1-4】直接部署"><a href="#【1-4】直接部署" class="headerlink" title="【1-4】直接部署"></a>【1-4】直接部署</h1><p>以下4步我已经写好了vagrantfile文件，大家可以下载我上传的vagrantfile和setup.sh文件，然后直接运行</p><p><a href="https://github.com/wenhaoliang/Kubernetes">https://github.com/wenhaoliang/Kubernetes</a></p><pre class=" language-bash"><code class="language-bash">vagrant up</code></pre><p>就可以自动化的生成对应的一台master节点和三台worker节点</p><h1 id="5-安装Docker-kubelet-kubeadm-kubectl"><a href="#5-安装Docker-kubelet-kubeadm-kubectl" class="headerlink" title="5.安装Docker kubelet kubeadm kubectl"></a>5.安装Docker kubelet kubeadm kubectl</h1><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span>  <span class="token string">"deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main"</span> <span class="token operator">>></span> /etc/apt/sources.list<span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y docker.io apt-transport-https curl kubelet kubeadm kubectl --allow-unauthenticated</code></pre><h1 id="6-设置hosts"><a href="#6-设置hosts" class="headerlink" title="6.设置hosts"></a>6.设置hosts</h1><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"192.168.8.170 master1192.168.8.171 worker1192.168.8.172 worker2192.168.8.173 worker3"</span> <span class="token operator">>></span> /etc/hosts</code></pre><p>这里要把IP和主机名字改成自己的</p><h1 id="7-关闭swap和关闭防火墙"><a href="#7-关闭swap和关闭防火墙" class="headerlink" title="7.关闭swap和关闭防火墙"></a>7.关闭swap和关闭防火墙</h1><pre class=" language-bash"><code class="language-bash">swapoff -aufw disable</code></pre><p>接下来我们打开登陆自己的虚拟机，进入master节点</p><h1 id="8-在master节点进入root账户"><a href="#8-在master节点进入root账户" class="headerlink" title="8.在master节点进入root账户"></a>8.在master节点进入root账户</h1><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">passwd</span> root<span class="token function">su</span> root</code></pre><h1 id="9-初始化init"><a href="#9-初始化init" class="headerlink" title="9.初始化init"></a>9.初始化init</h1><pre class=" language-bash"><code class="language-bash">kubeadm init \--apiserver-advertise-address<span class="token operator">=</span>192.168.8.170 \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.15.0 \--service-cidr<span class="token operator">=</span>10.1.0.0/16 \--pod-network-cidr<span class="token operator">=</span>10.244.0.0/16</code></pre><p>这里会生成token，要记录下来，类似于</p><pre class=" language-bash"><code class="language-bash">kubeadm <span class="token function">join</span> 192.168.8.170:6443 --token ufocob.upw1fa0fqfiuxego \    --discovery-token-ca-cert-hash sha256:52011414517c40d3079c4ac5d8296f77d80a70b7c20ddbb69ddb73a4e8f9bf9b</code></pre><h1 id="10-添加flannel网络插件"><a href="#10-添加flannel网络插件" class="headerlink" title="10.添加flannel网络插件"></a>10.添加flannel网络插件</h1><pre class=" language-bas"><code class="language-bas">kubeadm join 192.168.8.170:6443 --token ufocob.upw1fa0fqfiuxego \    --discovery-token-ca-cert-hash sha256:52011414517c40d3079c4ac5d8296f77d80a70b7c20ddbb69ddb73a4e8f9bf9b</code></pre><p>部署到此结束</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kube-proxy解析</title>
      <link href="/2020/01/03/kube-proxy-jie-xi/"/>
      <url>/2020/01/03/kube-proxy-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Kubernetes 在每个节点上运行网络代理。这反映每个节点上 Kubernetes API 中定义的服务，并且可以做简单的 TCP 和 UDP 流转发或在一组后端中轮询，进行 TCP 和 UDP 转发。目前服务集群 IP 和端口通过由服务代理打开的端口 的 Docker-links-compatible 环境变量找到。有一个可选的为这些集群 IP 提供集群 DNS 的插件。用户必须 通过 apiserver API 创建服务去配置代理。</p><p>一、<strong>kube-proxy 监听 API server 中 service 和 endpoint 的变化情况，并通过 userspace、iptables、ipvs 或 winuserspace 等 proxier 来为服务配置负载均衡（仅支持 TCP 和 UDP）。</strong></p><p><img src="/images/Kube-proxy%E8%A7%A3%E6%9E%90/kube-proxy.png" alt="kube-proxy"></p><ul><li>kube-proxy 其实就是管理 Service 的访问入口，包括集群内 Pod 到 Service 的访问和集群外访问 Service；</li><li>kube-proxy 管理 Service 的 Endpoints，该 Service 对外暴露一个 Virtual IP，也称为 Cluster IP, 集群内通过访问这个 Cluster IP:Port 就能访问到集群内对应的 Serivce 下的 Pod；</li><li>Service 是通过 Selector 选择的一组 Pods 的服务抽象，其实就是一个微服务，提供了服务的 LB 和反向代理的能力，而 kube-proxy 的主要作用就是负责 Service 的实现；</li><li>Service 一个重要作用就是，一个服务后端的 Pods 可能会随着生存灭亡而发生 IP 的改变，Service 的出现，给服务提供了一个固定的 IP，而无视后端 Endpoint 的变化，而这种关联的维护主要依赖 kube-proxy 实现；</li></ul><h1 id="二、kube-proxy-内部原理"><a href="#二、kube-proxy-内部原理" class="headerlink" title="二、kube-proxy 内部原理"></a>二、kube-proxy 内部原理</h1><h1 id="kube-proxy-当前实现了三种代理模式：-userspace、iptables以及ipvs，但是最新的实现方式是ipvs方式。"><a href="#kube-proxy-当前实现了三种代理模式：-userspace、iptables以及ipvs，但是最新的实现方式是ipvs方式。" class="headerlink" title="kube-proxy 当前实现了三种代理模式：   userspace、iptables以及ipvs，但是最新的实现方式是ipvs方式。**"></a>kube-proxy 当前实现了三种代理模式：   <del>userspace、iptables</del>以及ipvs，但是最新的实现方式是ipvs方式。**</h1><h2 id="1、-userspace-模式"><a href="#1、-userspace-模式" class="headerlink" title="1、 userspace 模式"></a>1、 userspace 模式</h2><p>在这种模式下，kube-proxy 持续监听 Service 以及 Endpoints 对象的变化；对每个 Service，它都为其在本地节点开放一个端口，作为其服务代理端口；发往该端口的请求会采用一定的策略转发给与该服务对应的后端 Pod 实体。kube-proxy 同时会在本地节点设置 iptables 规则，配置一个 Virtual IP，把发往 Virtual IP 的请求重定向到与该 Virtual IP 对应的服务代理端口上。<br>其工作流程大体如下：<br><img src="images/Kube-proxy%E8%A7%A3%E6%9E%90/Userspace.png" alt="Userspace"></p><p>分析： 该模式请求在到达 iptables 进行处理时就会进入内核，而 kube-proxy 监听则是在用户态，请求就形成了从用户态到内核态再返回到用户态的传递过程，一定程度降低了服务性能。</p><h2 id="2、iptables-模式"><a href="#2、iptables-模式" class="headerlink" title="2、iptables 模式"></a>2、iptables 模式</h2><p>kube-proxy 持续监听 Service 以及 Endpoints 对象的变化；但它并不在本地节点开启反向代理服务，而是把反向代理全部交给 iptables 来实现；即 iptables 直接将对 VIP 的请求转发给后端 Pod，通过 iptables 设置转发策略。<br>其工作流程大体如下：<br><img src="images/Kube-proxy%E8%A7%A3%E6%9E%90/iptables.png" alt="iptables"></p><p>分析： 该模式相比 userspace 模式，克服了请求在用户态-内核态反复传递的问题，性能上有所提升，但使用 iptables NAT 来完成转发，存在不可忽视的性能损耗，而且在大规模场景下，iptables 规则的条目会十分巨大，性能上还要再打折扣。</p><h2 id="3、ipvs-模式"><a href="#3、ipvs-模式" class="headerlink" title="3、ipvs 模式"></a>3、ipvs 模式</h2><p>与 iptables、userspace 模式一样，kube-proxy 依然监听 Service 以及 Endpoints 对象的变化；不过它并不创建反向代理，也不创建大量的 iptables 规则；而是通过 netlink 创建 ipvs 规则，并使用 k8s Service 与 Endpoints 信息，对所在节点的 ipvs 规则进行定期同步；netlink 与 iptables 底层都是基于 netfilter 钩子，但是 netlink 由于采用了 hash table 而且直接工作在内核态，在性能上比 iptables 更优。</p><p><img src="images/Kube-proxy%E8%A7%A3%E6%9E%90/ipvs.png" alt="ipvs"></p><p>分析： ipvs 是目前 kube-proxy 所支持的最新代理模式，相比使用 iptables，使用 ipvs 具有更高的性能。</p><h1 id="三、ipvs"><a href="#三、ipvs" class="headerlink" title="三、ipvs"></a>三、ipvs</h1><p><strong>什么是 IPVS ?</strong></p><p>IPVS (IP Virtual Server)是在 Netfilter 上层构建的，并作为 Linux 内核的一部分，实现传输层负载均衡。</p><p>IPVS 集成在 LVS（Linux Virtual Server，Linux 虚拟服务器）中，它在主机上运行，并在物理服务器集群前作为负载均衡器。IPVS 可以将基于 TCP 和 UDP 服务的请求定向到真实服务器，并使真实服务器的服务在单个IP地址上显示为虚拟服务。 因此，IPVS 自然支持 Kubernetes 服务。</p><p><strong>为什么为 Kubernetes 选择 IPVS ?</strong></p><p>随着 Kubernetes 的使用增长，其资源的可扩展性变得越来越重要。特别是，服务的可扩展性对于运行大型工作负载的开发人员/公司采用 Kubernetes 至关重要。</p><p>Kube-proxy 是服务路由的构建块，它依赖于经过强化攻击的 iptables 来实现支持核心的服务类型，如 ClusterIP 和 NodePort。 但是，iptables 难以扩展到成千上万的服务，因为它纯粹是为防火墙而设计的，并且基于内核规则列表。</p><p>尽管 Kubernetes 在版本v1.6中已经支持5000个节点，但使用 iptables 的 kube-proxy 实际上是将集群扩展到5000个节点的瓶颈。 一个例子是，在5000节点集群中使用 NodePort 服务，如果我们有2000个服务并且每个服务有10个 pod，这将在每个工作节点上至少产生20000个 iptable 记录，这可能使内核非常繁忙。</p><p>另一方面，使用基于 IPVS 的集群内服务负载均衡可以为这种情况提供很多帮助。 IPVS 专门用于负载均衡，并使用更高效的数据结构（哈希表），允许几乎无限的规模扩张。</p><h1 id="三、ipvs原理"><a href="#三、ipvs原理" class="headerlink" title="三、ipvs原理"></a>三、ipvs原理</h1><p><strong>ipvs的模型中有两个角色：</strong></p><p>调度器:Director，又称为Balancer。 调度器主要用于接受用户请求。</p><p>真实主机:Real Server，简称为RS。用于真正处理用户的请求。</p><p><strong>IP地址类型分为三种：</strong></p><p>Client IP: 客户端请求源IP，简称CIP。</p><p>Director Virtual IP: 调度器用于与客户端通信的IP地址，简称为VIP。</p><p>Real Server IP:  后端主机的用于与调度器通信的IP地址，简称为RIP。</p><p><img src="images/Kube-proxy%E8%A7%A3%E6%9E%90/ipvs3.png" alt="ipvs3"></p><p><strong>工作过程：</strong></p><p>1、当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP。</p><p>2、PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链。</p><p>3、ipvs会监听到达input链的数据包，比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器IP，然后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP。</p><p>4、POSTROUTING链通过选路，将数据包发送给Real Server</p><p>5、Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP。</p><p>6、Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kube-proxy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
